/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * CÃ©u is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#line 1 "samples/sample3.ceu"

#ifndef _CEU_APP_H
#define _CEU_APP_H

#include "ceu_types.h"

#define CEU_EXTS
#define CEU_ORGS
#define CEU_GOTO
#define CEU_CLEAR
#define CEU_RET
#define CEU_INTS
     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef s8 tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef s16 tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS 7

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#ifndef _CEU_THREADS_H
#define _CEU_THREADS_H

#include <pthread.h>
#define CEU_THREADS_T               pthread_t
#define CEU_THREADS_MUTEX_T         pthread_mutex_t
#define CEU_THREADS_COND_T          pthread_cond_t
#define CEU_THREADS_SELF()          pthread_self()
#define CEU_THREADS_CREATE(t,f,p)   pthread_create(t,NULL,f,p)
#define CEU_THREADS_DETACH(t)       pthread_detach(t)
/*
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m); printf("L[%d]\n",__LINE__)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m); printf("U[%d]\n",__LINE__)
*/
#define CEU_THREADS_MUTEX_LOCK(m)   pthread_mutex_lock(m)
#define CEU_THREADS_MUTEX_UNLOCK(m) pthread_mutex_unlock(m);
/*
#define CEU_THREADS_COND_WAIT(c,m)  pthread_cond_wait(c,m)
#define CEU_THREADS_COND_SIGNAL(c)  pthread_cond_signal(c)
*/

#endif

#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */
     /* TODO: pool should not depend on tceu_* */
#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    tceu_org_lnk** lnks;
                    /* lnks at 0-offset to share same struct with dynamic */
                    /* TODO: "lnks" field is unused for adt */
                    /* TODO: "lnks" field makes no sense for non-Ceu pools */
                    /* TODO: move it to an enclosing struct */
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#endif


#define CEU_IN__NONE 0
#define CEU_IN__STK 255
#define CEU_IN__ORG 254
#define CEU_IN__ORG_PSED 253
#define CEU_IN__CLEAR 252
#define CEU_IN__ok_killed 251
#define CEU_IN__INIT 250
#define CEU_IN__ASYNC 249
#define CEU_IN__THREAD 248
#define CEU_IN__WCLOCK 247
#define CEU_IN_SDL_QUIT 246
#define CEU_IN_SDL_REDRAW 245
#define CEU_IN_SDL_MOUSEBUTTONDOWN 244
#define CEU_IN_higher CEU_IN__INIT
#define CEU_IN_lower 244
#define CEU_OUT_n 0
      /* CEU_IN_, CEU_OUT_ */
#define CEU_FUN_IMG_Init
#define CEU_FUN_SDL_RenderPresent
#define CEU_FUN_SDL_SetRenderDrawColor
#define CEU_FUN_SDL_DestroyTexture
#define CEU_FUN_SDL_RenderFillRect
#define CEU_FUN_IMG_Load
#define CEU_FUN_SDL_DestroyRenderer
#define CEU_FUN_SDL_CreateTextureFromSurface
#define CEU_FUN_SDL_CreateWindow
#define CEU_FUN_SDL_CreateRenderer
#define CEU_FUN_SDL_FreeSurface
#define CEU_FUN_SDL_RenderCopy
#define CEU_FUN_SDL_DestroyWindow
   /* CEU_FUN_ */
typedef struct {
	SDL_MouseButtonEvent* _1;
} tceu__SDL_MouseButtonEvent_;
typedef struct {
	s32 _1;
} tceu__s32;
typedef struct {
	int _1;
} tceu__int;
typedef struct {
	bool _1;
} tceu__bool;
typedef struct {
	int _1;
	int _2;
	int _3;
	int _4;
} tceu__int__int__int__int;


/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */


typedef                         struct { /* BLOCK ln=29 */
                          int x;
                          int y;
                          int w;
                          int h;
                        }  CEU_SDL_Rect;

enum {
CEU_NONE1158,
CEU__OPTION___SDL_SURFACE__REF_NIL,
CEU__OPTION___SDL_SURFACE__REF_SOME
};

typedef struct CEU__Option___SDL_Surface__ref {
    u8 tag;
    union {
                                            struct { /* BLOCK ln=10 */
                                            } NIL;
                                            struct { /* BLOCK ln=10 */
                                              SDL_Surface* v;
                                            } SOME;
    };
}
 CEU__Option___SDL_Surface__ref;

enum {
CEU_NONE1164,
CEU__OPTION___SDL_TEXTURE__REF_NIL,
CEU__OPTION___SDL_TEXTURE__REF_SOME
};

typedef struct CEU__Option___SDL_Texture__ref {
    u8 tag;
    union {
                                            struct { /* BLOCK ln=17 */
                                            } NIL;
                                            struct { /* BLOCK ln=17 */
                                              SDL_Texture* v;
                                            } SOME;
    };
}
 CEU__Option___SDL_Texture__ref;

typedef struct CEU_Button {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 5 ];
                          struct { /* BLOCK ln=3 */
                            SDL_Renderer* ren;
                            CEU_SDL_Rect* rect;
                            bool on;
                            union {
                                union {
                                };
                              struct { /* BLOCK ln=3 */
                                union {
                                  struct { /* BLOCK ln=10 */
                                  u8 __fin_215_1: 1;
                                  u8 __fin_215_2: 1;
                                  u8 __fin_215_3: 1;
                                  u8 __fin_215_4: 1;
                                    CEU__Option___SDL_Surface__ref sur_normal;
                                    CEU__Option___SDL_Surface__ref sur_pressed;
                                    CEU__Option___SDL_Texture__ref tex_normal;
                                    CEU__Option___SDL_Texture__ref tex_pressed;
                                    union {
                                      union {
                                              union {
                                              };
                                              union {
                                              };
                                      };
                                          struct { /* BLOCK ln=14 */
                                            union {
                                            };
                                          } ;
                                      union {
                                              union {
                                              };
                                              union {
                                              };
                                      };
                                          struct { /* BLOCK ln=21 */
                                            union {
                                            };
                                          } ;
                                      union {
                                      };
                                          struct { /* BLOCK ln=28 */
                                            union {
                                            };
                                          } ;
                                      union {
                                      };
                                          struct { /* BLOCK ln=35 */
                                            union {
                                            };
                                          } ;
                                      struct {
                                        struct { /* BLOCK ln=39 */
                                          union {
                                            union {
                                            };
                                          };
                                        } ;
                                        struct { /* BLOCK ln=41 */
                                          union {
                                            struct { /* BLOCK ln=41 */
                                              union {
                                                union {
                                                };
                                                  struct { /* BLOCK ln=42 */
                                                    SDL_MouseButtonEvent* but_15;
                                                    union {
                                                      union {
                                                        union {
                                                        };
                                                      };
                                                        struct { /* BLOCK ln=44 */
                                                          union {
                                                              struct { /* BLOCK ln=47 */
                                                                union {
                                                                };
                                                              } ;
                                                          };
                                                        } ;
                                                    };
                                                  } ;
                                              };
                                            } ;
                                          };
                                        } ;
                                        struct { /* BLOCK ln=54 */
                                          union {
                                            struct { /* BLOCK ln=54 */
                                              union {
                                                union {
                                                };
                                                  struct { /* BLOCK ln=55 */
                                                    union {
                                                      union {
                                                      };
                                                        struct { /* BLOCK ln=56 */
                                                          union {
                                                          };
                                                        } ;
                                                        struct { /* BLOCK ln=58 */
                                                          union {
                                                          };
                                                        } ;
                                                    };
                                                  } ;
                                              };
                                            } ;
                                          };
                                        } ;
                                      };
                                    };
                                  } ;
                                };
                              } ;
                            };
                          } ;

} CEU_Button;





typedef struct CEU_Bulb {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 4 ];
                          struct { /* BLOCK ln=65 */
                            SDL_Renderer* ren;
                            CEU_SDL_Rect* rect;
                            bool on;
                            union {
                                union {
                                };
                              struct { /* BLOCK ln=65 */
                                union {
                                  struct { /* BLOCK ln=71 */
                                  u8 __fin_358_1: 1;
                                  u8 __fin_358_2: 1;
                                  u8 __fin_358_3: 1;
                                  u8 __fin_358_4: 1;
                                    CEU__Option___SDL_Surface__ref sur_off;
                                    CEU__Option___SDL_Surface__ref sur_on;
                                    CEU__Option___SDL_Texture__ref tex_off;
                                    CEU__Option___SDL_Texture__ref tex_on;
                                    union {
                                      union {
                                      };
                                          struct { /* BLOCK ln=75 */
                                            union {
                                            };
                                          } ;
                                      union {
                                      };
                                          struct { /* BLOCK ln=82 */
                                            union {
                                            };
                                          } ;
                                      union {
                                      };
                                          struct { /* BLOCK ln=89 */
                                            union {
                                            };
                                          } ;
                                      union {
                                      };
                                          struct { /* BLOCK ln=96 */
                                            union {
                                            };
                                          } ;
                                      struct {
                                        struct { /* BLOCK ln=100 */
                                          union {
                                            union {
                                            };
                                          };
                                        } ;
                                        struct { /* BLOCK ln=102 */
                                          union {
                                            struct { /* BLOCK ln=102 */
                                              union {
                                                union {
                                                };
                                                  struct { /* BLOCK ln=103 */
                                                    union {
                                                      union {
                                                      };
                                                        struct { /* BLOCK ln=104 */
                                                          union {
                                                          };
                                                        } ;
                                                        struct { /* BLOCK ln=106 */
                                                          union {
                                                          };
                                                        } ;
                                                    };
                                                  } ;
                                              };
                                            } ;
                                          };
                                        } ;
                                      };
                                    };
                                  } ;
                                };
                              } ;
                            };
                          } ;

} CEU_Bulb;





enum {
CEU_NONE1170,
CEU__OPTION___SDL_WINDOW__REF_NIL,
CEU__OPTION___SDL_WINDOW__REF_SOME
};

typedef struct CEU__Option___SDL_Window__ref {
    u8 tag;
    union {
                            struct { /* BLOCK ln=13 */
                            } NIL;
                            struct { /* BLOCK ln=13 */
                              SDL_Window* v;
                            } SOME;
    };
}
 CEU__Option___SDL_Window__ref;

enum {
CEU_NONE1176,
CEU__OPTION___SDL_RENDERER__REF_NIL,
CEU__OPTION___SDL_RENDERER__REF_SOME
};

typedef struct CEU__Option___SDL_Renderer__ref {
    u8 tag;
    union {
                            struct { /* BLOCK ln=22 */
                            } NIL;
                            struct { /* BLOCK ln=22 */
                              SDL_Renderer* v;
                            } SOME;
    };
}
 CEU__Option___SDL_Renderer__ref;
typedef struct CEU_Main {
#ifdef CEU_ORGS
  struct tceu_org org;
#endif
  tceu_trl trls_[ 7 ];
  struct { /* BLOCK ln=1 */
    union {
        union {
        };
      struct { /* BLOCK ln=1 */
        int _ret_0;
        union {
            struct { /* BLOCK ln=1 */
              union {
                union {
                  struct { /* BLOCK ln=1 */
                  u8 __fin_587_1: 1;
                  u8 __fin_587_2: 1;
                    int w_width;
                    int w_height;
                    int button_width;
                    int button_height;
                    int bulb_width;
                    int bulb_height;
                    CEU__Option___SDL_Window__ref win;
                    CEU__Option___SDL_Renderer__ref renderer;
                    CEU_SDL_Rect screen;
                    CEU_SDL_Rect button_rect;
                    CEU_SDL_Rect bulb_rect;
                    union {
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                          union {
                            union {
                            };
                            union {
                            };
                            union {
                            };
                            union {
                            };
                          };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      union {
                              union {
                              };
                              union {
                              };
                      };
                          struct { /* BLOCK ln=19 */
                            union {
                            };
                          } ;
                      union {
                              union {
                              };
                              union {
                              };
                      };
                          struct { /* BLOCK ln=26 */
                            union {
                            };
                          } ;
                      union {
                      };
                      union {
                      };
                      union {
                      };
                      struct {
                        struct { /* BLOCK ln=42 */
                          union {
                            union {
                            };
                          };
                        } ;
                        struct { /* BLOCK ln=44 */
                          union {
                            struct { /* BLOCK ln=44 */
                              union {
                                union {
                                };
                                  struct { /* BLOCK ln=45 */
                                    union {
                                      union {
                                      };
                                    };
                                  } ;
                              };
                            } ;
                          };
                        } ;
                        struct { /* BLOCK ln=49 */
                          struct CEU_Button button_18;
                        tceu_org_lnk __lnks_568_2[2];
                          struct CEU_Bulb bulb_19;
                        tceu_org_lnk __lnks_568_3[2];
                          union {
                                struct { /* BLOCK ln=50 */
                                  union {
                                  };
                                } ;
                                struct { /* BLOCK ln=56 */
                                  union {
                                  };
                                } ;
                            struct { /* BLOCK ln=61 */
                              union {
                                union {
                                };
                                  struct { /* BLOCK ln=62 */
                                    union {
                                      union {
                                        union {
                                        };
                                      };
                                    };
                                  } ;
                              };
                            } ;
                          };
                        } ;
                        struct { /* BLOCK ln=68 */
                          union {
                            struct { /* BLOCK ln=68 */
                              union {
                                union {
                                };
                                  struct { /* BLOCK ln=69 */
                                    union {
                                      union {
                                      };
                                    };
                                  } ;
                              };
                            } ;
                          };
                        } ;
                      };
                      union {
                      };
                    };
                  } ;
                };
              };
            } ;
        };
      } ;
    };
  } ;

} CEU_Main;






#endif

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */

/* TODO: #ifdef CEU_INTS: seqno, stk_curi, CEU_STK */

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


#ifdef __AVR
#ifdef CEU_OS
#error Understand this again!
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */
     /* TODO: pool should not depend on tceu_* */
#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    tceu_org_lnk** lnks;
                    /* lnks at 0-offset to share same struct with dynamic */
                    /* TODO: "lnks" field is unused for adt */
                    /* TODO: "lnks" field makes no sense for non-Ceu pools */
                    /* TODO: move it to an enclosing struct */
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->lnks  = lnks;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL) || defined(CEU_VECTOR_MALLOC)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

#endif

byte* ceu_vector_geti_ex (tceu_vector* vector, int idx, char* file, int line) {
    byte* ret = ceu_vector_geti(vector, idx);
    ceu_out_assert_msg_ex(ret!=NULL, "access out of bounds", file, line);
    return ret;
}
#endif

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

/**********************************************************************/

#ifdef CEU_STACK

void ceu_stack_pop_f (tceu_app* app, tceu_go* go) {
    go->stk_nxti = go->stk_curi;
#ifdef CEU_REENTRANT
    app->stki = go->stk_nxti;
#endif
    go->stk_curi -= stack_cur(go)->offset;
}

void ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr) {
    elem->offset = go->stk_nxti - go->stk_curi;
    go->stk_curi = go->stk_nxti;
    go->stk_nxti = stack_pushi(go, elem);
#ifdef CEU_REENTRANT
    app->stki = go->stk_nxti;
#endif
    *stack_cur(go) = *elem;
    if (ptr != NULL) {
        memcpy(stack_cur(go)->evt_buf, ptr, elem->evt_sz);
    }
}

#ifdef CEU_DEBUG
void ceu_stack_dump (tceu_go* go) {
    int i;
    printf("=== STACK-DUMP [%d -> %d]\n", go->stk_curi, go->stk_nxti);
    for (i=0; i<go->stk_nxti; i+=stack_sz(go,i)) {
        printf("[%d] evt=%d sz=%d\n", i, stack_get(go,i)->evt, stack_get(go,i)->evt_sz);
    }
}
#endif

/* TODO: move from 1=>0 (change also in code.lua) */
#ifdef CEU_ORGS
#ifndef CEU_ANA_NO_NESTED_TERMINATION
/*
 * All traversals for the "org" being cleared (as well as nested ones) must 
 * continue with the org in sequence.
 */
static int __ceu_isParent (tceu_org* parent, tceu_org* me) {
    return (parent==me) || (me!=NULL && __ceu_isParent(parent,me->up));
}
void ceu_sys_stack_clear_org (tceu_go* go, tceu_org* old, int lim) {
    int i;
    for (i=0; i<lim; i+=stack_sz((go),i)) {
        tceu_stk* stk = stack_get((go),i);
        if (stk->evt == CEU_IN__NONE) {
            continue;   /* already cleared: avoids accessing dangling pointer */
        }
        if (__ceu_isParent(old, (tceu_org*)stk->org)) {
            if (stk->stop == NULL) {        /* broadcast traversal */
                /* jump to next organism */
                stk->org = old->nxt;
                stk->trl = &((tceu_org*)old->nxt)->trls [
                            (old->n == 0) ?
                            ((tceu_org_lnk*)old)->lnk : 0
                          ];
                /* skip end-of-org-list organism */
                if (((tceu_org*)stk->org)->n == 0) {
                    stk->trl = &(((tceu_org*)stk->org)->nxt->trls [
                                ((tceu_org_lnk*)stk->org)->lnk
                               ]);
                    stk->org = ((tceu_org*)stk->org)->nxt;
                }
#if 0
/* TODO: BUG: _STK_ORG is not necessarily the parent for pool allocations */
/* TODO: remove if-0 when solved */
                ceu_out_msg_assert(!__ceu_isParent(old, stk->org),
                                "bug found [001]" );
#endif
            } else {                        /* ignore local traversals */
                stk->evt = CEU_IN__NONE;
            }
        }
    }
}
#endif
#endif

#endif  /* CEU_STACK */

/**********************************************************************/

#ifdef CEU_ORGS

void ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnks) {
    org->trls[idx].evt  = CEU_IN__ORG;
    org->trls[idx].lnks = lnks;
    lnks[0].nxt = (tceu_org*) &lnks[1];
    lnks[1].prv = (tceu_org*) &lnks[0];
    lnks[1].nxt = org;
    lnks[1].n   = 0;    /* marks end of linked list */
    lnks[1].lnk = idx+1;
    lnks[0].up = lnks[1].up = org;
}

int ceu_sys_org_spawn (tceu_app* _ceu_app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt,
                       tceu_org* neworg, tceu_nlbl neworg_lbl) {
    /* save the continuation to run after the constructor */
    _STK->trl->evt = CEU_IN__STK;
    _STK->trl->lbl = lbl_cnt;
    _STK->trl->stk = stack_curi(_ceu_go);
       /* awake in the same level as we are now (-1 vs the constructor push below) */

    /* prepare the new org to start */
    neworg->trls[0].evt = CEU_IN__STK;
    neworg->trls[0].lbl = neworg_lbl;
    neworg->trls[0].stk = stack_nxti(_ceu_go);

    {
        /* switch to ORG */
        tceu_stk stk;
                 stk.evt  = CEU_IN__STK;
                 stk.org  = neworg;
                 stk.trl  = &neworg->trls[0];
                 stk.stop = &neworg->trls[neworg->n]; /* don't follow the up link */
                 stk.evt_sz = 0;
        stack_push(_ceu_app, _ceu_go, &stk, NULL);
    }
    return RET_RESTART;
}

#endif

void ceu_sys_org (tceu_org* org, int n, int lbl,
                  int cls, int isDyn,
                  tceu_org* parent, tceu_org_lnk** lnks)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
    org->up = parent;
#ifdef CEU_IFCS
    org->cls = cls;
#endif
#endif
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING) || defined(CEU_OS_KERNEL)
    org->isAlive = 1;
#endif
#ifdef CEU_ORGS_WATCHING
    org->ret = 0;   /* TODO: ainda preciso disso? */
#endif
#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt = CEU_IN__STK;
    org->trls[0].lbl = lbl;

#ifdef CEU_ORGS
    if (lnks == NULL) {
        return;             /* main class */
    }

    /* re-link */
    {
        tceu_org_lnk* lst = &(*lnks)[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}

static void ceu_sys_bcast (tceu_app* _ceu_app, tceu_go* _ceu_go, tceu_stk* stk, void* evtp);

#ifdef CEU_ORGS
void ceu_sys_org_kill (tceu_app* _ceu_app, tceu_go* _ceu_go, tceu_org* me)
{
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    me->isAlive = 0;
#endif

    /* awake listeners after clear (this is a stack!) */
#ifdef CEU_ORGS_WATCHING
    /* TODO(speed): only if was ever watched! */
    {
        tceu_stk stk;
                 stk.evt  = CEU_IN__ok_killed;
                 stk.org  = _ceu_app->data;
                 stk.trl  = &_ceu_app->data->trls[0];
                 stk.stop = NULL;
                 stk.evt_sz = sizeof(tceu_kill);
        tceu_kill ps = { me, me->ret };

        /* Reuse the same stack level for multiple "kill" in sequence:
         *  - pools
         *  - TODO: incomplete? (nested kills?, kill adt+org?)
         *      - should not be reused in those cases?
         */
        if (_STK->evt == CEU_IN__ok_killed) {
            stack_pop(_ceu_app, _ceu_go);
        }

        ceu_sys_bcast(_ceu_app, _ceu_go, &stk, &ps);
    }
#endif
}

#ifdef CEU_ORGS_NEWS
void ceu_sys_org_free (tceu_org* me)
{
    /* re-link PRV <-> NXT */
    me->prv->nxt = me->nxt;
    me->nxt->prv = me->prv;

    /* free */
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
    ceu_pool_free((tceu_pool*)me->pool, (byte*)me);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
    if (me->pool->queue == NULL) {
        ceu_sys_realloc(me, 0);
    } else {
        ceu_pool_free((tceu_pool*)me->pool, (byte*)me);
    }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
    ceu_sys_realloc(me, 0);
#endif
}
#endif /* CEU_ORGS_NEWS */

#endif /* CEU_ORGS */

/**********************************************************************/

#ifdef CEU_ADTS_WATCHING
void ceu_sys_adt_kill (tceu_app* _ceu_app, tceu_go* _ceu_go, void* me)
{
    tceu_stk stk;
             stk.evt  = CEU_IN__ok_killed;
#ifdef CEU_ORGS
             stk.org  = _ceu_app->data;
#endif
             stk.trl  = &_ceu_app->data->trls[0];
             stk.stop = NULL;
             stk.evt_sz = sizeof(tceu_kill);
    ceu_sys_bcast(_ceu_app, _ceu_go, &stk, &me);
}
#endif

/**********************************************************************/

#ifdef CEU_CLEAR
int ceu_sys_clear (tceu_app* _ceu_app, tceu_go* _ceu_go, tceu_nlbl cnt,
                   tceu_org* org, tceu_trl* from, void* stop)
{
    /* save the continuation to run after the clear */
    /* trails[1] points to ORG blk ("clear trail") */
    _STK->trl->evt = CEU_IN__STK;
    _STK->trl->stk = stack_curi(_ceu_go);
    _STK->trl->lbl = cnt;

    {
        tceu_stk stk;
                 stk.evt    = CEU_IN__CLEAR;
                 stk.cnt    = _STK->trl;
#ifdef CEU_ORGS
                 stk.org    = org;
#endif
                 stk.trl    = from;
                 stk.stop   = stop;
                 stk.evt_sz = 0;
        stack_push(_ceu_app, _ceu_go, &stk, NULL);    /* continue after it */
    }

    return RET_RESTART;
}
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert_msg(0, msg);
/*
*/
#else
    ceu_out_assert_msg(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

#ifdef CEU_OS_KERNEL
u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */
#endif

static void ceu_sys_bcast (tceu_app* _ceu_app, tceu_go* _ceu_go, tceu_stk* stk, void* evtp)
{
#ifdef CEU_STACK
    stack_push(_ceu_app, _ceu_go, stk, evtp);
#else
    stk->evt_buf = evtp;
    *_ceu_go = *stk;
#endif
    for (;;)
    {
/* TODO: remove: no more invalidation? */
/* i.e., make sure we never emit NONE */
        if (_STK->evt == CEU_IN__NONE) {
            break;  /* invalidated emit or freed organism */
        }

#if 0
#ifdef CEU_DEBUG_TRAILS
printf("=== 1\n");
printf("STACK[%d]: evt=%d : seqno=%d\n",
    stack_curi(_ceu_go), _STK->evt, _ceu_app->seqno);
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
printf("\torg=%p/%d : [%d/%p]\n",
    _STK_ORG, _STK_ORG==_ceu_app->data, _STK_ORG->n, _STK_ORG->trls);
#else
printf("\tntrls=%d\n", CEU_NTRAILS);
#endif
#endif
#endif

        /* STK_ORG has been traversed to the end? */
        if (_STK->trl ==
            &_STK_ORG->trls[
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
                _STK_ORG->n
#else
                CEU_NTRAILS
#endif
            ])
        {
            /* end of traversal, reached the end of top org */
            if (_STK_ORG == _ceu_app->data) {
                break;  /* pop stack */
            }

#ifdef CEU_ORGS
            else {
                /* save current org before setting the next traversal */
                tceu_org* old = _STK_ORG;

                /* traverse next org */
                _STK_ORG_ATTR = old->nxt;
                _STK->trl = &((tceu_org*)old->nxt)->trls [
                                 (old->n == 0) ?
                                 ((tceu_org_lnk*)old)->lnk : 0
                            ];
                continue;
            }
#endif  /* CEU_ORGS */
        }

        /* continue traversing current org */

#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (_STK->trl->evt==CEU_IN__ORG) {
printf("\tTRY[%p] : evt=%d : seqno=%d : stk=%d : lbl=%d : org=%p->%p\n",
    _STK->trl, _STK->trl->evt, _STK->trl->stk, 0, _STK_LBL,
    &_STK->trl->lnks[0], &_STK->trl->lnks[1]);
} else
#endif
{
printf("\tTRY[%p] : evt=%d : seqno=%d : stk=%d : lbl=%d\n",
    _STK->trl, _STK->trl->evt, _STK->trl->stk, 0, _STK_LBL);
}
#endif

        /* jump into linked orgs */
#ifdef CEU_ORGS
        if (_STK->trl->evt == CEU_IN__ORG)
        {
            /* TODO(speed): jump LST */
            _STK_ORG_ATTR = _STK->trl->lnks[0].nxt;   /* jump FST */
            _STK->trl = &_STK_ORG->trls[0];
            continue; /* restart */
        }
#endif /* CEU_ORGS */

        /* EXECUTE THIS TRAIL ? */

        if (_STK->trl->evt != _STK->evt
#if defined(CEU_INTS) && defined(CEU_ORGS)
        ||  (_STK->evt<CEU_IN_lower && _STK->evto!=_STK->trl->evto)
#endif
        ) {
            goto _CEU_GO_NO_;
        }
#ifdef CEU_OS
        if (_STK->trl->evt == CEU_IN__NONE) {
            goto _CEU_GO_NO_; /* OS can emit NONE (to fill queue gaps) */
        }
#endif
#ifdef CEU_WATCHING
        if (_STK->evt == CEU_IN__ok_killed) {
            if (_STK->trl->org_or_adt != NULL &&
                _STK->trl->org_or_adt != ((tceu_kill*)evtp)->org_or_adt)
            {
                goto _CEU_GO_NO_;
            }
        }
        else
#endif
        {
#ifdef CEU_INTS
            if (_STK->evt<CEU_IN_lower && _STK->trl->seqno==_ceu_app->seqno) {
                goto _CEU_GO_NO_;
            }
#endif
        }

        /* execute this trail in the 2nd pass */
        _STK->trl->evt = CEU_IN__STK;
#ifdef CEU_STACK
        _STK->trl->stk = stack_curi(_ceu_go);
#endif
#ifdef CEU_DEBUG_TRAILS
printf("\t>>> OK\n");
#endif

_CEU_GO_NO_:

        _STK->trl++; /* next trail */
    }

    /* restore to initial state (org/trl/stop) */
    *_STK = *stk;
}

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
#ifdef CEU_STACK
#ifdef CEU_REENTRANT
    static
#endif
    byte CEU_STK[CEU_STACK_MAX];
#endif

    tceu_go go;
#ifdef CEU_STACK
            go.stk = CEU_STK;
#endif

    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

#ifdef CEU_INTS
    app->seqno++;
#endif

#ifdef CEU_STACK
    stack_init(app, &go);
#endif
    {
        tceu_stk stk;
                 stk.evt  = evt;
#ifdef CEU_ORGS
                 stk.org  = app->data;
#endif
                 stk.trl  = &app->data->trls[0];
#ifdef CEU_CLEAR
                 stk.stop = NULL;  /* traverse all (don't stop) */
#endif
#ifdef CEU_STACK
                 stk.evt_sz = sizeof(evtp);
#endif
        ceu_sys_bcast(app, &go, &stk, &evtp);
    }

#ifdef CEU_STACK
    for (;;)
    {
#endif
        for (;;)
        {
/* TODO: remove: no more invalidation? */
/* i.e., make sure we never emit NONE */
            if (STK->evt == CEU_IN__NONE) {
                break;  /* invalidated emit or freed organism */
            }

#ifdef CEU_DEBUG_TRAILS
#if 0
printf("=== 2\n");
#endif
printf("STACK[%d]: evt=%d : seqno=%d\n",
    stack_curi(&go), STK->evt, 0);
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
printf("\torg=%p/%d : [%d/%p]\n",
    STK_ORG, STK_ORG==app->data, STK_ORG->n, STK_ORG->trls);
#else
printf("\tntrls=%d\n", CEU_NTRAILS);
#endif
#endif

#ifdef CEU_CLEAR
            if (STK->trl == STK->stop) {    /* bounded trail traversal? */
                STK->stop = NULL;           /* back to default */
/* TODO: precisa desse NULL? */
                break;                      /* pop stack */
            }
#endif

            /* STK_ORG has been traversed to the end? */
            if (STK->trl ==
                &STK_ORG->trls[
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
                    STK_ORG->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                /* end of traversal, reached the end of top org */
                if (STK_ORG == app->data) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                /* end of current org */
                else {
                    /* save current org before setting the next traversal */
                    tceu_org* old = STK_ORG;

#if 0
                    /*
                     * Test is commented to simplify the code.
                     * "traverse-next-org" only required on that condition.
                     */
                    int to_kill_free = (STK->evt==CEU_IN__CLEAR && old->n!=0);
                    int stop_now = (STK->stop==(void*)old);
                    if (to_kill_free && stop_now) {
                    } else
#endif
                    {
                        /* traverse next org */
                        STK_ORG_ATTR = old->nxt;
                        STK->trl = &((tceu_org*)old->nxt)->trls [
                                    (old->n == 0) ?
                                    ((tceu_org_lnk*)old)->lnk : 0
                                  ];
                    }

                    if (STK->evt==CEU_IN__CLEAR && old->n!=0) {
                        ceu_sys_stack_clear_org(&go, old, stack_curi(&go));
                        if (STK->stop==(void*)old) {
#ifdef CEU_ORGS_WATCHING
                            /* HACK_10: (see adj.lua)
                             * save return value as global
                             * (in case spawn terminates immediately)
                             */
                            app->ret = old->ret;
#endif
                            /* pop this level as it was a bounded CLEAR on the
                             * given ORG nothing else to do in this level */
                            stack_pop(app, &go);
                            ceu_sys_org_kill(app, &go, old); /* has bcast/push */
                        } else {
                            /* pop/kill/push:
                             * terminate current CLEAR before kill */
#ifdef CEU_ORGS_WATCHING
                            tceu_stk stk = *stack_cur(&go);
                            stack_pop(app, &go); /* only if "kill" emit ok_killed */
#endif
                            ceu_sys_org_kill(app, &go, old); /* has bcast/push */
#ifdef CEU_ORGS_WATCHING
                            stack_push(app, &go, &stk, NULL);
#endif
                        }
#ifdef CEU_ORGS_NEWS
                        if (old->isDyn) {
                            ceu_sys_org_free(old);
                        }
#endif
                    }
                    continue;   /* restart with kill */
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing current org */

            /* jump into linked orgs */
#ifdef CEU_ORGS
            if ( (STK->trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
              || (STK->trl->evt==CEU_IN__ORG_PSED && STK->evt==CEU_IN__CLEAR)
#endif
               )
            {
                if (STK->evt == CEU_IN__CLEAR) {
                    STK->trl->evt = CEU_IN__NONE;
                }
                /* TODO(speed): jump LST */
                STK_ORG_ATTR = STK->trl->lnks[0].nxt;   /* jump FST */
                STK->trl = &STK_ORG->trls[0];
                continue; /* restart */
            }
#endif /* CEU_ORGS */

            /* EXECUTE THIS TRAIL */
            if (
#ifdef CEU_CLEAR
                (STK->evt==CEU_IN__CLEAR && STK->trl->evt==CEU_IN__CLEAR) ||
#endif
                (STK->trl->evt==CEU_IN__STK
#ifdef CEU_STACK
                 && STK->trl->stk==stack_curi(&go)
#endif
                )
               )
            {
                int _ret;
                STK->trl->evt = CEU_IN__NONE;  /* clear trail */

#ifdef CEU_DEBUG_TRAILS
printf("\t<<< OK %d\n", STK->trl->lbl);
#endif

#if defined(CEU_OS_KERNEL) && defined(__AVR)
                CEU_APP_ADDR = app->addr;
#endif

                /*** CODE ***/
                _ret = app->code(app, &go);

#if defined(CEU_OS_KERNEL) && defined(__AVR)
                CEU_APP_ADDR = 0;
#endif

                switch (_ret) {
                    case RET_HALT:
                        break;
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
                    case RET_RESTART:
                        continue; /* restart */
#endif
#ifdef CEU_ASYNCS
                    case RET_ASYNC:
#ifdef ceu_out_async
                        ceu_out_async(app);
#endif
                        app->pendingAsyncs = 1;
                        break;
#endif
#ifdef CEU_RET
                    case RET_QUIT:
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
                        app->isAlive = 0;
#ifdef CEU_OS_KERNEL
                        CEU_GC = 1;
#endif
#endif
#ifdef CEU_LUA
                        lua_close(app->lua);
#endif
                        goto _CEU_GO_QUIT_;
#endif
                    default:
#ifdef CEU_DEBUG
                        ceu_out_assert(0);
#endif
                        break;
                }
            }

            /* DON'T EXECUTE THIS TRAIL */
            else
            {
#ifdef CEU_DEBUG_TRAILS
printf("\t<<< NO\n");
#endif
#ifdef CEU_CLEAR
                if (STK->evt==CEU_IN__CLEAR && STK->cnt!=STK->trl) {
                    STK->trl->evt = CEU_IN__NONE;    /* trail cleared */
                }
#endif
            }

            /* NEXT TRAIL */

#ifdef CEU_INTS
            if (STK->trl->evt<CEU_IN_lower && STK->trl->seqno!=app->seqno) {
                STK->trl->seqno = app->seqno-1;   /* keeps the gap tight */
            }
#endif

            STK->trl++;
        }

#ifdef CEU_STACK
        stack_pop(app, &go);
        if (stack_empty(&go)) {
            break;      /* reaction has terminated */
        }
    }
#endif

#ifdef CEU_RET
_CEU_GO_QUIT_:;
#endif

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        ceu_sys_go(app, CEU_IN_OS_START, NULL);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert_msg(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_out_assert,
    (void*) &ceu_out_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
#ifdef CEU_CLEAR
    (void*) &ceu_sys_clear,
#endif
    (void*) &ceu_sys_stack_push,
#ifdef CEU_ORGS
    (void*) &ceu_sys_stack_clear_org,
#endif
    (void*) &ceu_sys_org,
#ifdef CEU_ORGS
    (void*) &ceu_sys_org_trail,
    (void*) &ceu_sys_org_spawn,
#endif
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );
#endif

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

/*
printf(">>> %p %X %p[%x %x %x %x %x]\n", addr, size, init,
        ((unsigned char*)init)[5],
        ((unsigned char*)init)[6],
        ((unsigned char*)init)[7],
        ((unsigned char*)init)[8],
        ((unsigned char*)init)[9]);
printf("<<< %d %d\n", app->isAlive, app->ret);
*/

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */


#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */
     /* TODO: pool should not depend on tceu_* */
#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    tceu_org_lnk** lnks;
                    /* lnks at 0-offset to share same struct with dynamic */
                    /* TODO: "lnks" field is unused for adt */
                    /* TODO: "lnks" field makes no sense for non-Ceu pools */
                    /* TODO: move it to an enclosing struct */
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);

#endif

/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>


void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->lnks  = lnks;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif

#endif

#ifdef CEU_VECTOR
#ifndef _CEU_VECTOR_H
#define _CEU_VECTOR_H

#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_CLEAR) || defined(CEU_INTS) || defined(CEU_ORGS) || defined(CEU_REENTRANT)
#define CEU_STACK
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif
#if defined(CEU_ORGS_WATCHING) || defined(CEU_ADTS_WATCHING)
#define CEU_WATCHING
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
    #define CEU_STACK
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
    #define CEU_ORGS_WATCHING
    #define CEU_ADTS_WATCHING
    #define CEU_WATCHING
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert(v) \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)

    #define ceu_out_assert_msg_ex(v,msg,file,line)       \
        {                                                \
            int __ceu_v = v;                             \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {         \
                ceu_out_log(0, (long)"[");               \
                ceu_out_log(0, (long)(file));            \
                ceu_out_log(0, (long)":");               \
                ceu_out_log(2, (line));                  \
                ceu_out_log(0, (long)"] ");              \
                ceu_out_log(0, (long)"runtime error: "); \
                ceu_out_log(0, (long)(msg));             \
                ceu_out_log(0, (long)"\n");              \
            }                                            \
            ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(__ceu_v); \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((app)->sys_vec[CEU_SYS_CLEAR]))(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((app)->sys_vec[CEU_SYS_STACK_PUSH]))(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((app)->sys_vec[CEU_SYS_ORG_SPAWN]))(app,go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #ifndef ceu_out_assert
        #error "Missing definition for macro \"ceu_out_assert\"."
    #endif

    #ifndef ceu_out_log
        #error "Missing definition for macro \"ceu_out_log\"."
    #endif

    #define ceu_out_assert_msg_ex(v,msg,file,line)          \
        {                                                   \
            int __ceu_v = v;                                \
            if ((!(__ceu_v)) && ((msg)!=NULL)) {            \
                ceu_out_log(0, (long)"[");                  \
                ceu_out_log(0, (long)(file));               \
                ceu_out_log(0, (long)":");                  \
                ceu_out_log(2, line);                       \
                ceu_out_log(0, (long)"] ");                 \
                ceu_out_log(0, (long)"runtime error: ");    \
                ceu_out_log(0, (long)(msg));                \
                ceu_out_log(0, (long)"\n");                 \
            }                                               \
            ceu_out_assert(__ceu_v);                        \
        }
    #define ceu_out_assert_msg(v,msg) ceu_out_assert_msg_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(app,go,cnt,org,from,stop) \
            ceu_sys_clear(app,go,cnt,org,from,stop)
#endif

#ifdef CEU_STACK
    #define ceu_out_stack_push(app,go,elem,ptr) \
            ceu_sys_stack_push(app,go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif
#endif

    #define ceu_out_org(app,org,n,lbl,cls,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,cls,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(app, go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(app, go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {                          \
        lua_State** p = &l;                             \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p);  \
    }

    #define ceu_lua_objlen(set, l, idx) {                       \
        tceu__lua_State___int p = { l, idx };                   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_OBJLEN, &p);   \
    }

#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
    #define ceu_lua_objlen(set,l,idx)            set = lua_objlen(l,idx)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

#ifdef CEU_STACK
typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */
#endif

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
#ifdef CEU_INTS                 /* R-9: size of trails for internal events */
        u8        seqno;        /* TODO(ram): 2 bits is enough */
#ifdef CEU_ORGS
        void*     evto;
#endif
#endif
    };

    /* IN__STK */
#ifdef CEU_STACK
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };
#endif

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif

    /* _ok_killed */
#ifdef CEU_WATCHING
    struct {
        tceu_nevt evt4;
        tceu_nlbl lbl4;
        void*     org_or_adt;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurseÂ´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    struct {
        tceu_nevt evt;  /* TODO: small in the end of struct? */
#ifdef CEU_STACK
        u8        evt_sz;
        u8        offset;
#endif
        tceu_trl* trl;  /* trail being traversed */

        union {
            struct {
#ifdef CEU_CLEAR
                void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_CLEAR) || defined(CEU_ORGS)
                void* stop;     /* stop at this trl/org */
                    /* traversals may be bounded to org/trl
                     * default (NULL) is to traverse everything */
                    /* TODO: could be shared w/ evto */
#endif
            };
#if defined(CEU_ORGS) && defined(CEU_INTS)
            void* evto; /* emitting org */
#endif
        };

#ifdef CEU_ORGS
        void* org;      /* org being traversed */
#endif
    };

    /* out of "struct{...}" to be aligned */
#ifdef CEU_STACK
    byte  evt_buf[0];
#else
    void* evt_buf;
#endif
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_WATCHING
typedef struct {
    void* org_or_adt;
    int ret;
} tceu_kill;
#endif

/* TCEU_GO */

#ifdef CEU_STACK

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    byte*     stk;
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define CEU_STACK_MAX   128*sizeof(tceu_stk)
    /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
    #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
    */

#ifdef CEU_REENTRANT
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = (app)->stki
#else
#define stack_init(app,go) (go)->stk_curi = (go)->stk_nxti = 0
#endif
#define stack_empty(go)    ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)    (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)      stack_get((go),(go)->stk_curi)
#define stack_nxt(go)      stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)     ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)     ((go)->stk_curi)
#define stack_nxti(go)     ((go)->stk_nxti)
#define stack_pushi(go,e)  ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)   (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(app,go)                                       \
    ceu_out_assert_msg(!stack_empty(go), "stack underflow");    \
    ceu_stack_pop_f((app),(go));

#define stack_push(app,go,elem,ptr)                             \
    ceu_out_assert_msg(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((app),(go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#else   /* !CEU_STACK */

typedef tceu_stk tceu_go;

#define STK  (&go)
#define _STK (_ceu_go)
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)
#define _STK_LBL (_STK->trl->lbl)

#endif  /* CEU_STACK */

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
#ifdef CEU_INTS
    u8 seqno:         2;
#endif
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_REENTRANT
    tceu_nstk stki;
#endif

#if defined(CEU_RET) || defined(CEU_ORGS_WATCHING)
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif

#ifdef CEU_STACK
void      ceu_sys_stack_push (tceu_app* app, tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int cls, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_app* app, tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */


typedef struct {
    int   max;
    int   nxt;
    int   unit;
    byte* mem;
} tceu_vector;

#define CEU_VECTOR_DCL(name, type, max)  \
    type        name##_mem[max+1];       \
    tceu_vector name;
                /* [STRING] max+1: extra space for '\0' */

#define ceu_vector_getlen(vec) ((vec)->nxt)
#define ceu_vector_getmax(vec) ((vec)->max > 0 ? (vec)->max : 0)

void  ceu_vector_init   (tceu_vector* vector, int max, int unit, byte* mem);
int   ceu_vector_setlen (tceu_vector* vector, int len);
byte* ceu_vector_geti   (tceu_vector* vector, int idx);
int   ceu_vector_seti   (tceu_vector* vector, int idx, byte* v);
int   ceu_vector_push   (tceu_vector* vector, byte* v);
int   ceu_vector_concat (tceu_vector* to, tceu_vector* fr);
int   ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n);

#if 0
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
#endif

#ifndef _CEU_VECTOR_C
#define _CEU_VECTOR_C



void ceu_vector_init (tceu_vector* vector, int max, int unit, byte* mem) {
    vector->nxt  = 0;
    vector->max  = max;
    vector->unit = unit;
    vector->mem  = (max==0) ? NULL : mem;

    /* [STRING] */
    if (vector->mem != NULL) {
        vector->mem[0] = '\0';
    }
}

#ifdef CEU_VECTOR_MALLOC
static void* ceu_vector_resize (tceu_vector* vector, int n) {
    ceu_out_assert_msg(vector->max <= 0, "bug found");

    if (n == 0) {
        /* free */
        if (vector->mem != NULL) {
            vector->max = 0;
            ceu_out_realloc(vector->mem, 0);
            vector->mem = NULL;
        }
    } else {
        /* Java does the same? */
        n = (n*3/2) + 1;
        if (n < 10) {
            n = 10;
        }

        vector->max = -n;
        vector->mem = (byte*)ceu_out_realloc(vector->mem, n*vector->unit + 1);
                                                        /* [STRING] +1 */
    }

    return vector->mem;
}
#endif

/* can only decrease vector->nxt */
int ceu_vector_setlen (tceu_vector* vector, int nxt) {
    if (nxt > vector->nxt) {
        return 0;
    } else {
        vector->nxt = nxt;

        /* [STRING] */
        if (vector->mem != NULL) {
            vector->mem[nxt*vector->unit] = '\0';
        }

#ifdef CEU_VECTOR_MALLOC
        /* shrink malloc'ed arrays */
        if (vector->max <= 0) {
            if (ceu_vector_resize(vector,nxt)==NULL && nxt>0) {
                return 0;
            }
        }
#endif

        return 1;
    }
}

/* can only get within idx < vector->nxt */
byte* ceu_vector_geti (tceu_vector* vector, int idx) {
    if (idx >= vector->nxt) {
        return NULL;
    } else {
        return &vector->mem[idx*vector->unit];
    }
}

/* can only set within idx < vector->nxt */
int ceu_vector_seti (tceu_vector* vector, int idx, byte* v) {
    if (idx >= vector->nxt) {
        return 0;
    } else {
        memcpy(&vector->mem[idx*vector->unit], v, vector->unit);
        return 1;
    }
}

/* can only push within nxt < vector->max */
int ceu_vector_push (tceu_vector* vector, byte* v) {
#ifdef CEU_VECTOR_MALLOC
    /* grow malloc'ed arrays */
    if (vector->max <= 0) {
        while (vector->nxt >= -vector->max) {
            if (ceu_vector_resize(vector,vector->nxt+1) == NULL) {
                return 0;
            }
        }
    }
#endif
#ifdef CEU_VECTOR_MALLOC
#ifdef CEU_VECTOR_POOL
    else
#endif
#endif
#ifdef CEU_VECTOR_POOL
    if (vector->nxt >= vector->max) {
        return 0;
    }
#endif

    memcpy(&vector->mem[vector->nxt*vector->unit], v, vector->unit);
    vector->nxt++;
    vector->mem[vector->nxt*vector->unit] = '\0';    /* [STRING] */
    return 1;
}

int ceu_vector_concat (tceu_vector* to, tceu_vector* fr) {
    if (to == fr) {
        return 0;
    } else {
        /* TODO: memcpy */
        int i;
        for (i=0; i<fr->nxt; i++) {
            byte* v = ceu_vector_geti(fr, i);
            if (v == NULL) {
                return 0;
            } else if (!ceu_vector_push(to,v)) {
                return 0;
            }
        }
    }
    return 1;
}

int ceu_vector_concat_buffer (tceu_vector* to, const char* fr, int n) {
    /* TODO: memcpy */
    int i;
    for (i=0; i<n; i++) {
        if (!ceu_vector_push(to,(byte*)&fr[i])) {
            return 0;
        }
    }
    return 1;
}

#endif

#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */


/* goto labels */
enum {
    Main_Set_out_0 = 0,
    Button_ParOr_sub_2_1 = 1,
    Button_ParOr_sub_3_2 = 2,
    Button_ParOr_out_3 = 3,
    Button_Awake_SDL_QUIT_4 = 4,
    Button_Awake_SDL_MOUSEBUTTONDOWN_5 = 5,
    Button_EmitInt_cont_6 = 6,
    Button_Awake_SDL_REDRAW_7 = 7,
    Button_Clear_8 = 8,
    Button_Block__fin_9 = 9,
    Button_Clear_10 = 10,
    Class_Button = 11,
    Button_Class_free_Button_12 = 12,
    Bulb_ParOr_sub_2_13 = 13,
    Bulb_ParOr_out_14 = 14,
    Bulb_Awake_SDL_QUIT_15 = 15,
    Bulb_Awake_SDL_REDRAW_16 = 16,
    Bulb_Clear_17 = 17,
    Bulb_Block__fin_18 = 18,
    Bulb_Clear_19 = 19,
    Class_Bulb = 20,
    Bulb_Class_free_Bulb_21 = 21,
    Main_ParOr_sub_2_22 = 22,
    Main_ParOr_sub_3_23 = 23,
    Main_ParOr_sub_4_24 = 24,
    Main_ParOr_out_25 = 25,
    Main_Awake_SDL_QUIT_26 = 26,
    Main_Awake_SDL_REDRAW_27 = 27,
    Main_Start_cnt_28 = 28,
    Main_Start_cnt_29 = 29,
    Main_Awake_is_on_30 = 30,
    Main_Clear_31 = 31,
    Main_Awake_SDL_REDRAW_32 = 32,
    Main_Clear_33 = 33,
    Main_Block__fin_34 = 34,
    Main_Clear_35 = 35,
    Main_Clear_36 = 36,
    Class_Main = 37,
    Main_Class_free_Main_38 = 38,

};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
#ifdef CEU_IFCS
static _tceu_app _CEU_APP = {
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
};
#endif

#ifdef CEU_ADTS_WATCHING_SDL_Rect
void CEU_SDL_Rect_kill (tceu_app* _ceu_app, tceu_go* go, CEU_SDL_Rect* me);
#endif
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU_SDL_Rect_free_dynamic (tceu_app* _ceu_app, CEU_SDL_Rect* me);
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU_SDL_Rect_free_static (tceu_app* _ceu_app, CEU_SDL_Rect* me, void* pool);
#endif
#endif

#ifdef CEU_ADTS_WATCHING_SDL_Rect
void CEU_SDL_Rect_kill (tceu_app* _ceu_app, tceu_go* go, CEU_SDL_Rect* me) {
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU_SDL_Rect_free_dynamic (tceu_app* _ceu_app, CEU_SDL_Rect* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU_SDL_Rect_free_static (tceu_app* _ceu_app, CEU_SDL_Rect* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif



#ifdef CEU_ADTS_WATCHING__Option___SDL_Surface__ref
void CEU__Option___SDL_Surface__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Surface__ref* me);
#endif
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Surface__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me);
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Surface__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me, void* pool);
#endif
#endif

CEU__Option___SDL_Surface__ref* CEU__OPTION___SDL_SURFACE__REF_NIL_assert (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_SURFACE__REF_NIL, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Surface__ref
void CEU__OPTION___SDL_SURFACE__REF_NIL_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Surface__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_SURFACE__REF_NIL_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_SURFACE__REF_NIL_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

CEU__Option___SDL_Surface__ref* CEU__OPTION___SDL_SURFACE__REF_SOME_assert (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_SURFACE__REF_SOME, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Surface__ref
void CEU__OPTION___SDL_SURFACE__REF_SOME_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Surface__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_SURFACE__REF_SOME_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_SURFACE__REF_SOME_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

#ifdef CEU_ADTS_WATCHING__Option___SDL_Surface__ref
void CEU__Option___SDL_Surface__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Surface__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_SURFACE__REF_NIL:
            CEU__OPTION___SDL_SURFACE__REF_NIL_kill(_ceu_app, go, me);
            break;
        case CEU__OPTION___SDL_SURFACE__REF_SOME:
            CEU__OPTION___SDL_SURFACE__REF_SOME_kill(_ceu_app, go, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Surface__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_SURFACE__REF_NIL:
            CEU__OPTION___SDL_SURFACE__REF_NIL_free_dynamic(_ceu_app, me);
            break;
        case CEU__OPTION___SDL_SURFACE__REF_SOME:
            CEU__OPTION___SDL_SURFACE__REF_SOME_free_dynamic(_ceu_app, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Surface__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Surface__ref* me, void* pool) {
    switch (me->tag) {
        case CEU__OPTION___SDL_SURFACE__REF_NIL:
            CEU__OPTION___SDL_SURFACE__REF_NIL_free_static(_ceu_app, me, pool);
            break;
        case CEU__OPTION___SDL_SURFACE__REF_SOME:
            CEU__OPTION___SDL_SURFACE__REF_SOME_free_static(_ceu_app, me, pool);
            break;
    }
}
#endif
#endif

CEU__Option___SDL_Surface__ref CEU__OPTION___SDL_SURFACE__REF_pack (SDL_Surface* ptr) {
    CEU__Option___SDL_Surface__ref ret;
    if (ptr == NULL) {
        ret.tag = CEU__OPTION___SDL_SURFACE__REF_NIL;
    } else {
        ret.tag = CEU__OPTION___SDL_SURFACE__REF_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
#if 0
// TODO: noew requires explicit conversions
SDL_Surface* CEU__OPTION___SDL_SURFACE__REF_unpack (CEU__Option___SDL_Surface__ref me) {
    if (me.tag == CEU__OPTION___SDL_SURFACE__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif


#ifdef CEU_ADTS_WATCHING__Option___SDL_Texture__ref
void CEU__Option___SDL_Texture__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Texture__ref* me);
#endif
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Texture__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me);
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Texture__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me, void* pool);
#endif
#endif

CEU__Option___SDL_Texture__ref* CEU__OPTION___SDL_TEXTURE__REF_NIL_assert (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_TEXTURE__REF_NIL, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Texture__ref
void CEU__OPTION___SDL_TEXTURE__REF_NIL_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Texture__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_TEXTURE__REF_NIL_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_TEXTURE__REF_NIL_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

CEU__Option___SDL_Texture__ref* CEU__OPTION___SDL_TEXTURE__REF_SOME_assert (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_TEXTURE__REF_SOME, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Texture__ref
void CEU__OPTION___SDL_TEXTURE__REF_SOME_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Texture__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_TEXTURE__REF_SOME_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_TEXTURE__REF_SOME_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

#ifdef CEU_ADTS_WATCHING__Option___SDL_Texture__ref
void CEU__Option___SDL_Texture__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Texture__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_TEXTURE__REF_NIL:
            CEU__OPTION___SDL_TEXTURE__REF_NIL_kill(_ceu_app, go, me);
            break;
        case CEU__OPTION___SDL_TEXTURE__REF_SOME:
            CEU__OPTION___SDL_TEXTURE__REF_SOME_kill(_ceu_app, go, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Texture__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_TEXTURE__REF_NIL:
            CEU__OPTION___SDL_TEXTURE__REF_NIL_free_dynamic(_ceu_app, me);
            break;
        case CEU__OPTION___SDL_TEXTURE__REF_SOME:
            CEU__OPTION___SDL_TEXTURE__REF_SOME_free_dynamic(_ceu_app, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Texture__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Texture__ref* me, void* pool) {
    switch (me->tag) {
        case CEU__OPTION___SDL_TEXTURE__REF_NIL:
            CEU__OPTION___SDL_TEXTURE__REF_NIL_free_static(_ceu_app, me, pool);
            break;
        case CEU__OPTION___SDL_TEXTURE__REF_SOME:
            CEU__OPTION___SDL_TEXTURE__REF_SOME_free_static(_ceu_app, me, pool);
            break;
    }
}
#endif
#endif

CEU__Option___SDL_Texture__ref CEU__OPTION___SDL_TEXTURE__REF_pack (SDL_Texture* ptr) {
    CEU__Option___SDL_Texture__ref ret;
    if (ptr == NULL) {
        ret.tag = CEU__OPTION___SDL_TEXTURE__REF_NIL;
    } else {
        ret.tag = CEU__OPTION___SDL_TEXTURE__REF_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
#if 0
// TODO: noew requires explicit conversions
SDL_Texture* CEU__OPTION___SDL_TEXTURE__REF_unpack (CEU__Option___SDL_Texture__ref me) {
    if (me.tag == CEU__OPTION___SDL_TEXTURE__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif


#ifdef CEU_ADTS_WATCHING__Option___SDL_Window__ref
void CEU__Option___SDL_Window__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Window__ref* me);
#endif
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Window__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me);
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Window__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me, void* pool);
#endif
#endif

CEU__Option___SDL_Window__ref* CEU__OPTION___SDL_WINDOW__REF_NIL_assert (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_WINDOW__REF_NIL, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Window__ref
void CEU__OPTION___SDL_WINDOW__REF_NIL_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Window__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_WINDOW__REF_NIL_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_WINDOW__REF_NIL_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

CEU__Option___SDL_Window__ref* CEU__OPTION___SDL_WINDOW__REF_SOME_assert (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_WINDOW__REF_SOME, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Window__ref
void CEU__OPTION___SDL_WINDOW__REF_SOME_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Window__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_WINDOW__REF_SOME_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_WINDOW__REF_SOME_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

#ifdef CEU_ADTS_WATCHING__Option___SDL_Window__ref
void CEU__Option___SDL_Window__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Window__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_WINDOW__REF_NIL:
            CEU__OPTION___SDL_WINDOW__REF_NIL_kill(_ceu_app, go, me);
            break;
        case CEU__OPTION___SDL_WINDOW__REF_SOME:
            CEU__OPTION___SDL_WINDOW__REF_SOME_kill(_ceu_app, go, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Window__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_WINDOW__REF_NIL:
            CEU__OPTION___SDL_WINDOW__REF_NIL_free_dynamic(_ceu_app, me);
            break;
        case CEU__OPTION___SDL_WINDOW__REF_SOME:
            CEU__OPTION___SDL_WINDOW__REF_SOME_free_dynamic(_ceu_app, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Window__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Window__ref* me, void* pool) {
    switch (me->tag) {
        case CEU__OPTION___SDL_WINDOW__REF_NIL:
            CEU__OPTION___SDL_WINDOW__REF_NIL_free_static(_ceu_app, me, pool);
            break;
        case CEU__OPTION___SDL_WINDOW__REF_SOME:
            CEU__OPTION___SDL_WINDOW__REF_SOME_free_static(_ceu_app, me, pool);
            break;
    }
}
#endif
#endif

CEU__Option___SDL_Window__ref CEU__OPTION___SDL_WINDOW__REF_pack (SDL_Window* ptr) {
    CEU__Option___SDL_Window__ref ret;
    if (ptr == NULL) {
        ret.tag = CEU__OPTION___SDL_WINDOW__REF_NIL;
    } else {
        ret.tag = CEU__OPTION___SDL_WINDOW__REF_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
#if 0
// TODO: noew requires explicit conversions
SDL_Window* CEU__OPTION___SDL_WINDOW__REF_unpack (CEU__Option___SDL_Window__ref me) {
    if (me.tag == CEU__OPTION___SDL_WINDOW__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif


#ifdef CEU_ADTS_WATCHING__Option___SDL_Renderer__ref
void CEU__Option___SDL_Renderer__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Renderer__ref* me);
#endif
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Renderer__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me);
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Renderer__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me, void* pool);
#endif
#endif

CEU__Option___SDL_Renderer__ref* CEU__OPTION___SDL_RENDERER__REF_NIL_assert (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_RENDERER__REF_NIL, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Renderer__ref
void CEU__OPTION___SDL_RENDERER__REF_NIL_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Renderer__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_RENDERER__REF_NIL_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_RENDERER__REF_NIL_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

CEU__Option___SDL_Renderer__ref* CEU__OPTION___SDL_RENDERER__REF_SOME_assert (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me, char* file, int line) {
    ceu_out_assert_msg_ex(me->tag == CEU__OPTION___SDL_RENDERER__REF_SOME, "invalid tag", file, line);
    return me;
}

#ifdef CEU_ADTS_WATCHING__Option___SDL_Renderer__ref
void CEU__OPTION___SDL_RENDERER__REF_SOME_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Renderer__ref* me) {
    ceu_sys_adt_kill(_ceu_app, go, me);
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__OPTION___SDL_RENDERER__REF_SOME_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me) {
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__OPTION___SDL_RENDERER__REF_SOME_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me, void* pool) {
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif

#ifdef CEU_ADTS_WATCHING__Option___SDL_Renderer__ref
void CEU__Option___SDL_Renderer__ref_kill (tceu_app* _ceu_app, tceu_go* go, CEU__Option___SDL_Renderer__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_RENDERER__REF_NIL:
            CEU__OPTION___SDL_RENDERER__REF_NIL_kill(_ceu_app, go, me);
            break;
        case CEU__OPTION___SDL_RENDERER__REF_SOME:
            CEU__OPTION___SDL_RENDERER__REF_SOME_kill(_ceu_app, go, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif

#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU__Option___SDL_Renderer__ref_free_dynamic (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me) {
    switch (me->tag) {
        case CEU__OPTION___SDL_RENDERER__REF_NIL:
            CEU__OPTION___SDL_RENDERER__REF_NIL_free_dynamic(_ceu_app, me);
            break;
        case CEU__OPTION___SDL_RENDERER__REF_SOME:
            CEU__OPTION___SDL_RENDERER__REF_SOME_free_dynamic(_ceu_app, me);
            break;
#ifdef CEU_DEBUG
        default:
            ceu_out_assert_msg(0, "invalid tag");
#endif
    }
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU__Option___SDL_Renderer__ref_free_static (tceu_app* _ceu_app, CEU__Option___SDL_Renderer__ref* me, void* pool) {
    switch (me->tag) {
        case CEU__OPTION___SDL_RENDERER__REF_NIL:
            CEU__OPTION___SDL_RENDERER__REF_NIL_free_static(_ceu_app, me, pool);
            break;
        case CEU__OPTION___SDL_RENDERER__REF_SOME:
            CEU__OPTION___SDL_RENDERER__REF_SOME_free_static(_ceu_app, me, pool);
            break;
    }
}
#endif
#endif

CEU__Option___SDL_Renderer__ref CEU__OPTION___SDL_RENDERER__REF_pack (SDL_Renderer* ptr) {
    CEU__Option___SDL_Renderer__ref ret;
    if (ptr == NULL) {
        ret.tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
    } else {
        ret.tag = CEU__OPTION___SDL_RENDERER__REF_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
#if 0
// TODO: noew requires explicit conversions
SDL_Renderer* CEU__OPTION___SDL_RENDERER__REF_unpack (CEU__Option___SDL_Renderer__ref me) {
    if (me.tag == CEU__OPTION___SDL_RENDERER__REF_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
#endif




/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

#endif

#ifdef CEU_ORGS
static void _ceu_constr_533 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 533 */
/* NODE: Block 532 */

#line 50 "samples/sample3.ceu"
    {/* NODE: Stmts 531 */

#line 50 "samples/sample3.ceu"
    {/* NODE: Set 1048 */

#line 50 "samples/sample3.ceu"
/* SET: . *//* NODE: Op1_& 520 */

#line 50 "samples/sample3.ceu"
    (((*((CEU_Button*)__ceu_org)).ren)) = ((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->renderer),__FILE__,__LINE__)->SOME.v));/* NODE: Set 1049 */

#line 51 "samples/sample3.ceu"
/* SET: . *//* NODE: Op1_& 525 */

#line 51 "samples/sample3.ceu"
    (((*((CEU_Button*)__ceu_org)).rect)) = (&((CEU_Main*)_STK_ORG)->button_rect);/* NODE: Set 1050 */

#line 52 "samples/sample3.ceu"
/* SET: . *//* NODE: NUMBER 529 */

#line 52 "samples/sample3.ceu"
    (((*((CEU_Button*)__ceu_org)).on)) = 0;
#line 50 "samples/sample3.ceu"
    }
#line 50 "samples/sample3.ceu"
/* CLEAR: Block (50) */
#line 50 "samples/sample3.ceu"
    }}
static void _ceu_constr_553 (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
/* NODE: Dcl_constr 553 */
/* NODE: Block 552 */

#line 56 "samples/sample3.ceu"
    {/* NODE: Stmts 551 */

#line 56 "samples/sample3.ceu"
    {/* NODE: Set 1051 */

#line 56 "samples/sample3.ceu"
/* SET: . *//* NODE: Op1_& 540 */

#line 56 "samples/sample3.ceu"
    (((*((CEU_Bulb*)__ceu_org)).ren)) = ((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->renderer),__FILE__,__LINE__)->SOME.v));/* NODE: Set 1052 */

#line 57 "samples/sample3.ceu"
/* SET: . *//* NODE: Op1_& 545 */

#line 57 "samples/sample3.ceu"
    (((*((CEU_Bulb*)__ceu_org)).rect)) = (&((CEU_Main*)_STK_ORG)->bulb_rect);/* NODE: Set 1053 */

#line 58 "samples/sample3.ceu"
/* SET: . *//* NODE: NUMBER 549 */

#line 58 "samples/sample3.ceu"
    (((*((CEU_Bulb*)__ceu_org)).on)) = 0;
#line 56 "samples/sample3.ceu"
    }
#line 56 "samples/sample3.ceu"
/* CLEAR: Block (56) */
#line 56 "samples/sample3.ceu"
    }}

#endif

#ifdef CEU_THREADS
/* THREADS_C */

#endif

/* FUNCTIONS_C */


#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static int ceu_app_go (tceu_app* _ceu_app , tceu_go* _ceu_go) {
    int _CEU_LBL = _STK->trl->lbl;
#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _STK_ORG;
#endif
    _ceu_app->lst.trl = _STK->trl;
    _ceu_app->lst.lbl = _CEU_LBL;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _CEU_LBL, _STK_ORG);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_CEU_LBL) {
        /* NODE: Root 600 */
/* NODE: Dcl_cls 0 */

#line 1 "samples/sample3.ceu"
case Class_Main:;/* NODE: Block 1152 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Stmts 1151 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Block 606 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Stmts 605 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Dcl_var 602 */
/* NODE: SetBlock 604 */
/* NODE: Block 598 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Stmts 597 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Stmts 594 */

#line 1 "samples/sample3.ceu"
    {/* NODE: Block 587 */

#line 1 "samples/sample3.ceu"
    /*  FINALIZE */
_STK_ORG->trls[ 6 ].evt   = CEU_IN__CLEAR;
_STK_ORG->trls[ 6 ].lbl   = Main_Block__fin_34;

#line 1 "samples/sample3.ceu"
    ((CEU_Main*)_STK_ORG)->__fin_587_1 = 0;
#line 1 "samples/sample3.ceu"
    ((CEU_Main*)_STK_ORG)->__fin_587_2 = 0;
#line 1 "samples/sample3.ceu"
    {
#line 1 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->win).tag = CEU__OPTION___SDL_WINDOW__REF_NIL;

#line 1 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->renderer).tag = CEU__OPTION___SDL_RENDERER__REF_NIL;
/* NODE: Stmts 585 */

#line 4 "./sdl.ceu"
    {/* NODE: Stmts 610 */

#line 4 "./sdl.ceu"
    {/* NODE: Dcl_ext 609 */

#line 4 "./sdl.ceu"
    }/* NODE: Stmts 613 */

#line 5 "./sdl.ceu"
    {/* NODE: Dcl_ext 612 */

#line 5 "./sdl.ceu"
    }/* NODE: Stmts 617 */

#line 6 "./sdl.ceu"
    {/* NODE: Dcl_ext 616 */

#line 6 "./sdl.ceu"
    }/* NODE: Stmts 626 */

#line 8 "./sdl.ceu"
    {/* NODE: Dcl_nat 618 */
/* NODE: Dcl_nat 619 */
/* NODE: Dcl_nat 620 */
/* NODE: Dcl_nat 621 */
/* NODE: Dcl_nat 622 */
/* NODE: Dcl_nat 623 */
/* NODE: Dcl_nat 624 */
/* NODE: Dcl_nat 625 */

#line 8 "./sdl.ceu"
    }/* NODE: Stmts 640 */

#line 15 "./sdl.ceu"
    {/* NODE: Dcl_nat 627 */
/* NODE: Dcl_nat 628 */
/* NODE: Dcl_nat 629 */
/* NODE: Dcl_nat 630 */
/* NODE: Dcl_nat 631 */
/* NODE: Dcl_nat 632 */
/* NODE: Dcl_nat 633 */
/* NODE: Dcl_nat 634 */
/* NODE: Dcl_nat 635 */
/* NODE: Dcl_nat 636 */
/* NODE: Dcl_nat 637 */
/* NODE: Dcl_nat 638 */
/* NODE: Dcl_nat 639 */

#line 15 "./sdl.ceu"
    }/* NODE: Dcl_adt 16 */
/* NODE: Stmts 825 */

#line 3 "./my_types.ceu"
    {
#line 3 "./my_types.ceu"
    }/* NODE: Stmts 924 */

#line 65 "./my_types.ceu"
    {
#line 65 "./my_types.ceu"
    }/* NODE: Stmts 929 */

#line 4 "samples/sample3.ceu"
    {/* NODE: Dcl_var 926 */
/* NODE: Set 930 */

#line 4 "samples/sample3.ceu"
/* SET: w_width *//* NODE: NUMBER 361 */

#line 4 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->w_width) = 640;
#line 4 "samples/sample3.ceu"
    }/* NODE: Stmts 935 */

#line 5 "samples/sample3.ceu"
    {/* NODE: Dcl_var 932 */
/* NODE: Set 936 */

#line 5 "samples/sample3.ceu"
/* SET: w_height *//* NODE: NUMBER 364 */

#line 5 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->w_height) = 480;
#line 5 "samples/sample3.ceu"
    }/* NODE: Stmts 941 */

#line 7 "samples/sample3.ceu"
    {/* NODE: Dcl_var 938 */
/* NODE: Set 942 */

#line 7 "samples/sample3.ceu"
/* SET: button_width *//* NODE: NUMBER 367 */

#line 7 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->button_width) = 190;
#line 7 "samples/sample3.ceu"
    }/* NODE: Stmts 947 */

#line 8 "samples/sample3.ceu"
    {/* NODE: Dcl_var 944 */
/* NODE: Set 948 */

#line 8 "samples/sample3.ceu"
/* SET: button_height *//* NODE: NUMBER 370 */

#line 8 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->button_height) = 60;
#line 8 "samples/sample3.ceu"
    }/* NODE: Stmts 953 */

#line 10 "samples/sample3.ceu"
    {/* NODE: Dcl_var 950 */
/* NODE: Set 954 */

#line 10 "samples/sample3.ceu"
/* SET: bulb_width *//* NODE: NUMBER 373 */

#line 10 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->bulb_width) = 138;
#line 10 "samples/sample3.ceu"
    }/* NODE: Stmts 959 */

#line 11 "samples/sample3.ceu"
    {/* NODE: Dcl_var 956 */
/* NODE: Set 960 */

#line 11 "samples/sample3.ceu"
/* SET: bulb_height *//* NODE: NUMBER 376 */

#line 11 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->bulb_height) = 224;
#line 11 "samples/sample3.ceu"
    }/* NODE: Stmts 963 */

#line 13 "samples/sample3.ceu"
    {/* NODE: Dcl_adt 1170 */
/* NODE: Dcl_var 962 */

#line 13 "samples/sample3.ceu"
    }/* NODE: Finalize 402 */

#line 14 "samples/sample3.ceu"
    ((CEU_Main*)_STK_ORG)->__fin_587_2 = 1;/* NODE: Set 964 */

#line 15 "samples/sample3.ceu"
/* SET: win *//* NODE: Op1_& 390 */

#line 15 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->win) = (CEU__OPTION___SDL_WINDOW__REF_pack(SDL_CreateWindow("(3) Hello World!",SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,(((CEU_Main*)_STK_ORG)->w_width),(((CEU_Main*)_STK_ORG)->w_height),SDL_WINDOW_SHOWN)));/* NODE: Stmts 967 */

#line 22 "samples/sample3.ceu"
    {/* NODE: Dcl_adt 1176 */
/* NODE: Dcl_var 966 */

#line 22 "samples/sample3.ceu"
    }/* NODE: Finalize 427 */

#line 23 "samples/sample3.ceu"
    ((CEU_Main*)_STK_ORG)->__fin_587_1 = 1;/* NODE: Set 968 */

#line 24 "samples/sample3.ceu"
/* SET: renderer *//* NODE: Op1_& 415 */

#line 24 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->renderer) = (CEU__OPTION___SDL_RENDERER__REF_pack(SDL_CreateRenderer(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->win),__FILE__,__LINE__)->SOME.v)),(-1),0)));/* NODE: Stmts 973 */

#line 30 "samples/sample3.ceu"
    {/* NODE: Dcl_var 970 */
/* NODE: Set 974 */

#line 30 "samples/sample3.ceu"
/* SET: screen *//* NODE: Adt_constr_root 436 */

#line 30 "samples/sample3.ceu"
    {/* NODE: Adt_constr_one 435 */

#line 30 "samples/sample3.ceu"
    CEU_SDL_Rect __ceu_adt_435;

#line 30 "samples/sample3.ceu"
    {/* NODE: ExpList 434 */
/* NODE: NUMBER 430 */
/* NODE: NUMBER 431 */
/* NODE: Var 432 */
/* NODE: Var 433 */

#line 30 "samples/sample3.ceu"
    __ceu_adt_435.x = 0;
#line 30 "samples/sample3.ceu"
    __ceu_adt_435.y = 0;
#line 30 "samples/sample3.ceu"
    __ceu_adt_435.w = (((CEU_Main*)_STK_ORG)->w_width);
#line 30 "samples/sample3.ceu"
    __ceu_adt_435.h = (((CEU_Main*)_STK_ORG)->w_height);
#line 30 "samples/sample3.ceu"
    }
#line 30 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->screen) = __ceu_adt_435;
#line 30 "samples/sample3.ceu"
    }
#line 30 "samples/sample3.ceu"
    }/* NODE: Stmts 979 */

#line 31 "samples/sample3.ceu"
    {/* NODE: Dcl_var 976 */
/* NODE: Set 980 */

#line 31 "samples/sample3.ceu"
/* SET: button_rect *//* NODE: Adt_constr_root 456 */

#line 31 "samples/sample3.ceu"
    {/* NODE: Adt_constr_one 455 */

#line 31 "samples/sample3.ceu"
    CEU_SDL_Rect __ceu_adt_455;

#line 31 "samples/sample3.ceu"
    {/* NODE: ExpList 454 */
/* NODE: Op2_- 446 */
/* NODE: Op2_+ 451 */
/* NODE: Var 452 */
/* NODE: Var 453 */

#line 31 "samples/sample3.ceu"
    __ceu_adt_455.x = (((((CEU_Main*)_STK_ORG)->w_width)/2)-((((CEU_Main*)_STK_ORG)->button_width)/2));
#line 31 "samples/sample3.ceu"
    __ceu_adt_455.y = (((((CEU_Main*)_STK_ORG)->w_height)/2)+(((CEU_Main*)_STK_ORG)->button_height));
#line 31 "samples/sample3.ceu"
    __ceu_adt_455.w = (((CEU_Main*)_STK_ORG)->button_width);
#line 31 "samples/sample3.ceu"
    __ceu_adt_455.h = (((CEU_Main*)_STK_ORG)->button_height);
#line 31 "samples/sample3.ceu"
    }
#line 31 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->button_rect) = __ceu_adt_455;
#line 31 "samples/sample3.ceu"
    }
#line 31 "samples/sample3.ceu"
    }/* NODE: Stmts 985 */

#line 35 "samples/sample3.ceu"
    {/* NODE: Dcl_var 982 */
/* NODE: Set 986 */

#line 35 "samples/sample3.ceu"
/* SET: bulb_rect *//* NODE: Adt_constr_root 476 */

#line 35 "samples/sample3.ceu"
    {/* NODE: Adt_constr_one 475 */

#line 35 "samples/sample3.ceu"
    CEU_SDL_Rect __ceu_adt_475;

#line 35 "samples/sample3.ceu"
    {/* NODE: ExpList 474 */
/* NODE: Op2_- 466 */
/* NODE: Op2_- 471 */
/* NODE: Var 472 */
/* NODE: Var 473 */

#line 35 "samples/sample3.ceu"
    __ceu_adt_475.x = (((((CEU_Main*)_STK_ORG)->w_width)/2)-((((CEU_Main*)_STK_ORG)->bulb_width)/2));
#line 35 "samples/sample3.ceu"
    __ceu_adt_475.y = (((((CEU_Main*)_STK_ORG)->w_height)/2)-(((CEU_Main*)_STK_ORG)->bulb_height));
#line 35 "samples/sample3.ceu"
    __ceu_adt_475.w = (((CEU_Main*)_STK_ORG)->bulb_width);
#line 35 "samples/sample3.ceu"
    __ceu_adt_475.h = (((CEU_Main*)_STK_ORG)->bulb_height);
#line 35 "samples/sample3.ceu"
    }
#line 35 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->bulb_rect) = __ceu_adt_475;
#line 35 "samples/sample3.ceu"
    }
#line 35 "samples/sample3.ceu"
    }/* NODE: CallStmt 482 */

#line 39 "samples/sample3.ceu"
    IMG_Init(IMG_INIT_PNG);/* NODE: ParOr 582 */

#line 41 "samples/sample3.ceu"
/* ParOr: spawn subs */
#line 41 "samples/sample3.ceu"
    {
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_2_22;
#ifdef CEU_STACK
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#endif
#ifdef CEU_DEBUG
    ceu_out_assert_msg(trl > _STK->trl, "bug found");
#endif
}

#line 41 "samples/sample3.ceu"
    {
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_3_23;
#ifdef CEU_STACK
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#endif
#ifdef CEU_DEBUG
    ceu_out_assert_msg(trl > _STK->trl, "bug found");
#endif
}

#line 41 "samples/sample3.ceu"
    {
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ 5 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Main_ParOr_sub_4_24;
#ifdef CEU_STACK
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#endif
#ifdef CEU_DEBUG
    ceu_out_assert_msg(trl > _STK->trl, "bug found");
#endif
}
/* NODE: Block 486 */

#line 42 "samples/sample3.ceu"
    {/* NODE: Stmts 485 */

#line 42 "samples/sample3.ceu"
    {/* NODE: Stmts 1013 */

#line 42 "samples/sample3.ceu"
    {/* NODE: Nothing 987 */
/* NODE: Await 484 */

#line 42 "samples/sample3.ceu"
    _CEU_NO_484_:
    if (0) { goto _CEU_NO_484_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_QUIT;
    _STK->trl->lbl = Main_Awake_SDL_QUIT_26;

#line 42 "samples/sample3.ceu"
    	return RET_HALT;
#line 42 "samples/sample3.ceu"
    case Main_Awake_SDL_QUIT_26:;

#line 42 "samples/sample3.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1222 */
/* NODE: Nothing 1223 */

#line 42 "samples/sample3.ceu"
    }
#line 42 "samples/sample3.ceu"
    }
#line 42 "samples/sample3.ceu"
/* CLEAR: Block (42) */
#line 42 "samples/sample3.ceu"
    }
#line 41 "samples/sample3.ceu"
/* PAROR JOIN */
#line 41 "samples/sample3.ceu"
    _CEU_LBL = Main_ParOr_out_25;
goto _CEU_GOTO_;

#line 41 "samples/sample3.ceu"
case Main_ParOr_sub_2_22:;/* NODE: Block 514 */

#line 44 "samples/sample3.ceu"
    {/* NODE: Stmts 513 */

#line 44 "samples/sample3.ceu"
    {/* NODE: Block 1020 */

#line 44 "samples/sample3.ceu"
    {/* NODE: Stmts 1019 */

#line 44 "samples/sample3.ceu"
    {/* NODE: Stmts 1018 */

#line 44 "samples/sample3.ceu"
    {
#line 44 "samples/sample3.ceu"
    }/* NODE: Loop 1017 */

#line 44 "samples/sample3.ceu"
    for (;;) {
/* NODE: Block 511 */

#line 45 "samples/sample3.ceu"
    {/* NODE: Stmts 510 */

#line 45 "samples/sample3.ceu"
    {/* NODE: Stmts 1047 */

#line 44 "samples/sample3.ceu"
    {/* NODE: Nothing 1021 */
/* NODE: Await 1014 */

#line 44 "samples/sample3.ceu"
    _CEU_NO_1014_:
    if (0) { goto _CEU_NO_1014_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_REDRAW;
    _STK->trl->lbl = Main_Awake_SDL_REDRAW_27;

#line 44 "samples/sample3.ceu"
    	return RET_HALT;
#line 44 "samples/sample3.ceu"
    case Main_Awake_SDL_REDRAW_27:;

#line 44 "samples/sample3.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1224 */
/* NODE: Nothing 1225 */

#line 44 "samples/sample3.ceu"
    }/* NODE: CallStmt 498 */

#line 45 "samples/sample3.ceu"
    SDL_SetRenderDrawColor(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->renderer),__FILE__,__LINE__)->SOME.v)),0x00,0x00,0x00,0xFF);/* NODE: CallStmt 509 */

#line 46 "samples/sample3.ceu"
    SDL_RenderFillRect(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->renderer),__FILE__,__LINE__)->SOME.v)),((SDL_Rect*)(&((CEU_Main*)_STK_ORG)->screen)));
#line 45 "samples/sample3.ceu"
    }
#line 45 "samples/sample3.ceu"
/* CLEAR: Block (45) */
#line 45 "samples/sample3.ceu"
    }
#line 44 "samples/sample3.ceu"
    }

#line 44 "samples/sample3.ceu"
    }
#line 44 "samples/sample3.ceu"
/* CLEAR: Block (44) */
#line 44 "samples/sample3.ceu"
    }
#line 44 "samples/sample3.ceu"
    }
#line 44 "samples/sample3.ceu"
/* CLEAR: Block (44) */
#line 44 "samples/sample3.ceu"
    }
#line 41 "samples/sample3.ceu"
case Main_ParOr_sub_3_23:;/* NODE: Block 568 */

#line 49 "samples/sample3.ceu"
    {
#line 49 "samples/sample3.ceu"
    #ifdef CEU_ORGS
ceu_out_org_trail(_STK_ORG, 2, (tceu_org_lnk*) &((CEU_Main*)_STK_ORG)->__lnks_568_2);
#endif

#line 49 "samples/sample3.ceu"
    #ifdef CEU_ORGS
ceu_out_org_trail(_STK_ORG, 3, (tceu_org_lnk*) &((CEU_Main*)_STK_ORG)->__lnks_568_3);
#endif

#line 49 "samples/sample3.ceu"
    /* switch to blk trail */
_STK->trl = &_STK_ORG->trls[ 4 ];
/* NODE: Stmts 567 */

#line 49 "samples/sample3.ceu"
    {/* NODE: Dcl_var 534 */

#line 49 "samples/sample3.ceu"
/* start org: button */
#line 49 "samples/sample3.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _STK_ORG is not necessarily the parent for pool allocations */
    ceu_out_org(_ceu_app, ((tceu_org*) &(((CEU_Main*)_STK_ORG)->button_18)),5,Class_Button,
                1,
                0,
                _STK_ORG, &_STK_ORG->trls[2].lnks);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 49 "samples/sample3.ceu"
        _ceu_constr_533(_ceu_app, ((tceu_org*) &(((CEU_Main*)_STK_ORG)->button_18)), _ceu_go);

#line 49 "samples/sample3.ceu"
        return ceu_out_org_spawn(_ceu_app, _ceu_go, Main_Start_cnt_28,((tceu_org*) &(((CEU_Main*)_STK_ORG)->button_18)),Class_Button);
case Main_Start_cnt_28:;
/* NODE: Dcl_var 554 */

#line 55 "samples/sample3.ceu"
/* start org: bulb */
#line 55 "samples/sample3.ceu"
        /* resets org memory and starts org.trail[0]=Class_XXX */
    /* TODO: BUG: _STK_ORG is not necessarily the parent for pool allocations */
    ceu_out_org(_ceu_app, ((tceu_org*) &(((CEU_Main*)_STK_ORG)->bulb_19)),4,Class_Bulb,
                2,
                0,
                _STK_ORG, &_STK_ORG->trls[3].lnks);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */

#line 55 "samples/sample3.ceu"
        _ceu_constr_553(_ceu_app, ((tceu_org*) &(((CEU_Main*)_STK_ORG)->bulb_19)), _ceu_go);

#line 55 "samples/sample3.ceu"
        return ceu_out_org_spawn(_ceu_app, _ceu_go, Main_Start_cnt_29,((tceu_org*) &(((CEU_Main*)_STK_ORG)->bulb_19)),Class_Bulb);
case Main_Start_cnt_29:;
/* NODE: Block 1057 */

#line 61 "samples/sample3.ceu"
    {/* NODE: Stmts 1056 */

#line 61 "samples/sample3.ceu"
    {/* NODE: Stmts 1055 */

#line 61 "samples/sample3.ceu"
    {
#line 61 "samples/sample3.ceu"
    }/* NODE: Loop 1054 */

#line 61 "samples/sample3.ceu"
    for (;;) {
/* NODE: Block 565 */

#line 62 "samples/sample3.ceu"
    {
#line 62 "samples/sample3.ceu"
    bool __ceu_is_on_20;
/* NODE: Stmts 564 */

#line 62 "samples/sample3.ceu"
    {/* NODE: Stmts 1062 */

#line 62 "samples/sample3.ceu"
    {/* NODE: Dcl_var 1059 */
/* NODE: Stmts 1107 */

#line 62 "samples/sample3.ceu"
    {/* NODE: Nothing 1065 */
/* NODE: Set 1064 */

#line 62 "samples/sample3.ceu"
/* SET: table: 0x262b400 *//* NODE: Await 558 */

#line 62 "samples/sample3.ceu"
    _CEU_NO_558_:
    if (0) { goto _CEU_NO_558_; /* avoids "not used" warning */ }
    _STK->trl->evt   = 1;
    _STK->trl->lbl   = Main_Awake_is_on_30;
#ifdef CEU_ORGS
    _STK->trl->evto  = (&((CEU_Main*)_STK_ORG)->button_18);
#endif
    _STK->trl->seqno =

#line 62 "samples/sample3.ceu"
            _ceu_app->seqno;    /* not reset with retry */
                            /* (before the label below) */

#line 62 "samples/sample3.ceu"
    	return RET_HALT;
#line 62 "samples/sample3.ceu"
    case Main_Awake_is_on_30:;

#line 62 "samples/sample3.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 62 "samples/sample3.ceu"
    {

#line 62 "samples/sample3.ceu"
        tceu__bool* __ceu_casted = (tceu__bool*) _STK->evt_buf;

#line 62 "samples/sample3.ceu"
        (__ceu_is_on_20) = ((__ceu_casted)->_1);
}
/* NODE: Nothing 1233 */
/* NODE: Nothing 1234 */

#line 62 "samples/sample3.ceu"
    }
#line 62 "samples/sample3.ceu"
    }/* NODE: Set 1112 */

#line 64 "samples/sample3.ceu"
/* SET: . *//* NODE: Var 562 */

#line 64 "samples/sample3.ceu"
    (((((CEU_Main*)_STK_ORG)->bulb_19).on)) = (__ceu_is_on_20);
#line 62 "samples/sample3.ceu"
    }
#line 62 "samples/sample3.ceu"
/* CLEAR: Block (62) */
#line 62 "samples/sample3.ceu"
    }
#line 61 "samples/sample3.ceu"
    }

#line 61 "samples/sample3.ceu"
    }
#line 61 "samples/sample3.ceu"
/* CLEAR: Block (61) */
#line 61 "samples/sample3.ceu"
    }
#line 49 "samples/sample3.ceu"
    }
#line 49 "samples/sample3.ceu"
/* CLEAR: Block (49) */
#line 49 "samples/sample3.ceu"
    }
#line 41 "samples/sample3.ceu"
case Main_ParOr_sub_4_24:;/* NODE: Block 581 */

#line 68 "samples/sample3.ceu"
    {/* NODE: Stmts 580 */

#line 68 "samples/sample3.ceu"
    {/* NODE: Block 1119 */

#line 68 "samples/sample3.ceu"
    {/* NODE: Stmts 1118 */

#line 68 "samples/sample3.ceu"
    {/* NODE: Stmts 1117 */

#line 68 "samples/sample3.ceu"
    {
#line 68 "samples/sample3.ceu"
    }/* NODE: Loop 1116 */

#line 68 "samples/sample3.ceu"
    for (;;) {
/* NODE: Block 578 */

#line 69 "samples/sample3.ceu"
    {/* NODE: Stmts 577 */

#line 69 "samples/sample3.ceu"
    {/* NODE: Stmts 1146 */

#line 68 "samples/sample3.ceu"
    {/* NODE: Nothing 1120 */
/* NODE: Await 1113 */

#line 68 "samples/sample3.ceu"
    _CEU_NO_1113_:
    if (0) { goto _CEU_NO_1113_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_REDRAW;
    _STK->trl->lbl = Main_Awake_SDL_REDRAW_32;

#line 68 "samples/sample3.ceu"
    	return RET_HALT;
#line 68 "samples/sample3.ceu"
    case Main_Awake_SDL_REDRAW_32:;

#line 68 "samples/sample3.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1236 */
/* NODE: Nothing 1237 */

#line 68 "samples/sample3.ceu"
    }/* NODE: CallStmt 576 */

#line 69 "samples/sample3.ceu"
    SDL_RenderPresent(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->renderer),__FILE__,__LINE__)->SOME.v)));
#line 69 "samples/sample3.ceu"
    }
#line 69 "samples/sample3.ceu"
/* CLEAR: Block (69) */
#line 69 "samples/sample3.ceu"
    }
#line 68 "samples/sample3.ceu"
    }

#line 68 "samples/sample3.ceu"
    }
#line 68 "samples/sample3.ceu"
/* CLEAR: Block (68) */
#line 68 "samples/sample3.ceu"
    }
#line 68 "samples/sample3.ceu"
    }
#line 68 "samples/sample3.ceu"
/* CLEAR: Block (68) */
#line 68 "samples/sample3.ceu"
    }
#line 41 "samples/sample3.ceu"
case Main_ParOr_out_25:;
#line 41 "samples/sample3.ceu"
/* CLEAR: ParOr (41) */
#line 41 "samples/sample3.ceu"
    return ceu_out_clear(_ceu_app, _ceu_go, Main_Clear_33, _STK_ORG,
                     &_STK_ORG->trls[ 0 ],
                     &_STK_ORG->trls[ 6 ]);

#line 41 "samples/sample3.ceu"
    case Main_Clear_33:;

#line 41 "samples/sample3.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ 0 ];
/* NODE: Stmts 1150 */

#line 73 "samples/sample3.ceu"
    {/* NODE: Set 1148 */

#line 73 "samples/sample3.ceu"
/* SET: _ret *//* NODE: NUMBER 583 */

#line 73 "samples/sample3.ceu"
    (((CEU_Main*)_STK_ORG)->_ret_0) = 0;
#line 73 "samples/sample3.ceu"
    #ifdef CEU_RET
    _ceu_app->ret = (((CEU_Main*)_STK_ORG)->_ret_0);
#endif
/* NODE: Escape 1149 */

#line 73 "samples/sample3.ceu"
    _CEU_LBL = Main_Set_out_0;
goto _CEU_GOTO_;

#line 73 "samples/sample3.ceu"
    }
#line 4 "./sdl.ceu"
    }
#line 1 "samples/sample3.ceu"
/* CLEAR: Block (1) */
#line 1 "samples/sample3.ceu"
    {
    int __ceu_from_fin;         /* separate dcl/set because of C++ */
    __ceu_from_fin = 0;         /* skip HALT */
    if (0) {

#line 1 "samples/sample3.ceu"
case Main_Block__fin_34:;
#line 1 "samples/sample3.ceu"
            __ceu_from_fin = 1;         /* stop on HALT */
    }

#line 1 "samples/sample3.ceu"
        if (((CEU_Main*)_STK_ORG)->__fin_587_1) {
        /* NODE: Finally 426 */
/* NODE: Block 425 */

#line 26 "samples/sample3.ceu"
    {/* NODE: Stmts 424 */

#line 26 "samples/sample3.ceu"
    {/* NODE: CallStmt 423 */

#line 26 "samples/sample3.ceu"
    SDL_DestroyRenderer(((CEU__OPTION___SDL_RENDERER__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->renderer),__FILE__,__LINE__)->SOME.v)));
#line 26 "samples/sample3.ceu"
    }
#line 26 "samples/sample3.ceu"
/* CLEAR: Block (26) */
#line 26 "samples/sample3.ceu"
    }    }

#line 1 "samples/sample3.ceu"
        if (((CEU_Main*)_STK_ORG)->__fin_587_2) {
        /* NODE: Finally 401 */
/* NODE: Block 400 */

#line 19 "samples/sample3.ceu"
    {/* NODE: Stmts 399 */

#line 19 "samples/sample3.ceu"
    {/* NODE: CallStmt 398 */

#line 19 "samples/sample3.ceu"
    SDL_DestroyWindow(((CEU__OPTION___SDL_WINDOW__REF_SOME_assert(_ceu_app, (&((CEU_Main*)_STK_ORG)->win),__FILE__,__LINE__)->SOME.v)));
#line 19 "samples/sample3.ceu"
    }
#line 19 "samples/sample3.ceu"
/* CLEAR: Block (19) */
#line 19 "samples/sample3.ceu"
    }    }

#line 1 "samples/sample3.ceu"
        if (__ceu_from_fin) {
        return RET_HALT;
    }
}

#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
/* CLEAR: Block (1) */
#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
    	return RET_HALT;
#line 1 "samples/sample3.ceu"
case Main_Set_out_0:;
#line 1 "samples/sample3.ceu"
/* CLEAR: SetBlock (1) */
#line 1 "samples/sample3.ceu"
    return ceu_out_clear(_ceu_app, _ceu_go, Main_Clear_36, _STK_ORG,
                     &_STK_ORG->trls[ 0 ],
                     &_STK_ORG->trls[ 7 ]);

#line 1 "samples/sample3.ceu"
    case Main_Clear_36:;

#line 1 "samples/sample3.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ 0 ];

#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
/* CLEAR: Block (1) */
#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
/* CLEAR: Block (1) */
#line 1 "samples/sample3.ceu"
    }
#line 1 "samples/sample3.ceu"
    #ifdef CEU_ORGS
{
    tceu_stk stk;
             stk.evt    = CEU_IN__CLEAR;
             stk.cnt    = NULL;
             stk.org    = _STK_ORG;
             stk.trl    = &_STK_ORG->trls[0];
             stk.stop   = _STK_ORG;
             stk.evt_sz = 0;
    stack_push(_ceu_app, _ceu_go, &stk, NULL);
}
#endif

#line 1 "samples/sample3.ceu"
    	return RET_QUIT;/* NODE: Dcl_cls 1 */

#line 3 "./my_types.ceu"
case Class_Button:;/* NODE: Block 823 */

#line 3 "./my_types.ceu"
    {/* NODE: Stmts 822 */

#line 3 "./my_types.ceu"
    {/* NODE: Block 658 */

#line 3 "./my_types.ceu"
    {/* NODE: Stmts 824 */

#line 3 "./my_types.ceu"
    {/* NODE: Block 215 */

#line 10 "./my_types.ceu"
    /*  FINALIZE */
_STK_ORG->trls[ 3 ].evt   = CEU_IN__CLEAR;
_STK_ORG->trls[ 3 ].lbl   = Button_Block__fin_9;

#line 10 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_1 = 0;
#line 10 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_2 = 0;
#line 10 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_3 = 0;
#line 10 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_4 = 0;
#line 10 "./my_types.ceu"
    {
#line 10 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->sur_normal).tag = CEU__OPTION___SDL_SURFACE__REF_NIL;

#line 10 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->tex_normal).tag = CEU__OPTION___SDL_TEXTURE__REF_NIL;

#line 10 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->sur_pressed).tag = CEU__OPTION___SDL_SURFACE__REF_NIL;

#line 10 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->tex_pressed).tag = CEU__OPTION___SDL_TEXTURE__REF_NIL;
/* NODE: Stmts 214 */

#line 10 "./my_types.ceu"
    {/* NODE: Stmts 677 */

#line 10 "./my_types.ceu"
    {/* NODE: Dcl_adt 1158 */
/* NODE: Dcl_var 676 */

#line 10 "./my_types.ceu"
    }/* NODE: Finalize 45 */

#line 11 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_4 = 1;/* NODE: Set 678 */

#line 12 "./my_types.ceu"
/* SET: sur_normal *//* NODE: Op1_& 33 */

#line 12 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->sur_normal) = (CEU__OPTION___SDL_SURFACE__REF_pack(IMG_Load("samples/imgs/normal.png")));/* NODE: Stmts 681 */

#line 17 "./my_types.ceu"
    {/* NODE: Dcl_adt 1164 */
/* NODE: Dcl_var 680 */

#line 17 "./my_types.ceu"
    }/* NODE: Finalize 69 */

#line 18 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_3 = 1;/* NODE: Set 682 */

#line 19 "./my_types.ceu"
/* SET: tex_normal *//* NODE: Op1_& 57 */

#line 19 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->tex_normal) = (CEU__OPTION___SDL_TEXTURE__REF_pack(SDL_CreateTextureFromSurface((((CEU_Button*)_STK_ORG)->ren),((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->sur_normal),__FILE__,__LINE__)->SOME.v)))));/* NODE: Stmts 685 */

#line 24 "./my_types.ceu"
    {/* NODE: Dcl_var 684 */

#line 24 "./my_types.ceu"
    }/* NODE: Finalize 89 */

#line 25 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_2 = 1;/* NODE: Set 686 */

#line 26 "./my_types.ceu"
/* SET: sur_pressed *//* NODE: Op1_& 77 */

#line 26 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->sur_pressed) = (CEU__OPTION___SDL_SURFACE__REF_pack(IMG_Load("samples/imgs/pressed.png")));/* NODE: Stmts 689 */

#line 31 "./my_types.ceu"
    {/* NODE: Dcl_var 688 */

#line 31 "./my_types.ceu"
    }/* NODE: Finalize 113 */

#line 32 "./my_types.ceu"
    ((CEU_Button*)_STK_ORG)->__fin_215_1 = 1;/* NODE: Set 690 */

#line 33 "./my_types.ceu"
/* SET: tex_pressed *//* NODE: Op1_& 101 */

#line 33 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->tex_pressed) = (CEU__OPTION___SDL_TEXTURE__REF_pack(SDL_CreateTextureFromSurface((((CEU_Button*)_STK_ORG)->ren),((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->sur_pressed),__FILE__,__LINE__)->SOME.v)))));/* NODE: ParOr 213 */

#line 38 "./my_types.ceu"
/* ParOr: spawn subs */
#line 38 "./my_types.ceu"
    {
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Button_ParOr_sub_2_1;
#ifdef CEU_STACK
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#endif
#ifdef CEU_DEBUG
    ceu_out_assert_msg(trl > _STK->trl, "bug found");
#endif
}

#line 38 "./my_types.ceu"
    {
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ 2 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Button_ParOr_sub_3_2;
#ifdef CEU_STACK
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#endif
#ifdef CEU_DEBUG
    ceu_out_assert_msg(trl > _STK->trl, "bug found");
#endif
}
/* NODE: Block 117 */

#line 39 "./my_types.ceu"
    {/* NODE: Stmts 116 */

#line 39 "./my_types.ceu"
    {/* NODE: Stmts 717 */

#line 39 "./my_types.ceu"
    {/* NODE: Nothing 691 */
/* NODE: Await 115 */

#line 39 "./my_types.ceu"
    _CEU_NO_115_:
    if (0) { goto _CEU_NO_115_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_QUIT;
    _STK->trl->lbl = Button_Awake_SDL_QUIT_4;

#line 39 "./my_types.ceu"
    	return RET_HALT;
#line 39 "./my_types.ceu"
    case Button_Awake_SDL_QUIT_4:;

#line 39 "./my_types.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1206 */
/* NODE: Nothing 1207 */

#line 39 "./my_types.ceu"
    }
#line 39 "./my_types.ceu"
    }
#line 39 "./my_types.ceu"
/* CLEAR: Block (39) */
#line 39 "./my_types.ceu"
    }
#line 38 "./my_types.ceu"
/* PAROR JOIN */
#line 38 "./my_types.ceu"
    _CEU_LBL = Button_ParOr_out_3;
goto _CEU_GOTO_;

#line 38 "./my_types.ceu"
case Button_ParOr_sub_2_1:;/* NODE: Block 172 */

#line 41 "./my_types.ceu"
    {/* NODE: Stmts 171 */

#line 41 "./my_types.ceu"
    {/* NODE: Block 721 */

#line 41 "./my_types.ceu"
    {/* NODE: Stmts 720 */

#line 41 "./my_types.ceu"
    {/* NODE: Stmts 719 */

#line 41 "./my_types.ceu"
    {
#line 41 "./my_types.ceu"
    }/* NODE: Loop 718 */

#line 41 "./my_types.ceu"
    for (;;) {
/* NODE: Block 169 */

#line 42 "./my_types.ceu"
    {/* NODE: Stmts 168 */

#line 42 "./my_types.ceu"
    {/* NODE: Stmts 726 */

#line 42 "./my_types.ceu"
    {/* NODE: Dcl_var 723 */
/* NODE: Stmts 767 */

#line 42 "./my_types.ceu"
    {/* NODE: Nothing 729 */
/* NODE: Set 728 */

#line 42 "./my_types.ceu"
/* SET: table: 0x262f220 *//* NODE: Await 120 */

#line 42 "./my_types.ceu"
    _CEU_NO_120_:
    if (0) { goto _CEU_NO_120_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_MOUSEBUTTONDOWN;
    _STK->trl->lbl = Button_Awake_SDL_MOUSEBUTTONDOWN_5;

#line 42 "./my_types.ceu"
    	return RET_HALT;
#line 42 "./my_types.ceu"
    case Button_Awake_SDL_MOUSEBUTTONDOWN_5:;

#line 42 "./my_types.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif

#line 42 "./my_types.ceu"
    {

#line 42 "./my_types.ceu"
        tceu__SDL_MouseButtonEvent_** __ceu_casted = (tceu__SDL_MouseButtonEvent_**) _STK->evt_buf;

#line 42 "./my_types.ceu"
        (((CEU_Button*)_STK_ORG)->but_15) = ((*(__ceu_casted))->_1);
}
/* NODE: Nothing 1208 */
/* NODE: Nothing 1209 */

#line 42 "./my_types.ceu"
    }
#line 42 "./my_types.ceu"
    }/* NODE: If 773 */

#line 43 "./my_types.ceu"
    if (((((*(((CEU_Button*)_STK_ORG)->but_15)).button))==SDL_BUTTON_LEFT)) {
/* NODE: Block 166 */

#line 44 "./my_types.ceu"
    {/* NODE: Stmts 165 */

#line 44 "./my_types.ceu"
    {/* NODE: If 777 */

#line 44 "./my_types.ceu"
    if ((((((((*(((CEU_Button*)_STK_ORG)->but_15)).x))>=(((*((CEU_Button*)_STK_ORG)->rect).x)))&&((((*(((CEU_Button*)_STK_ORG)->but_15)).y))>=(((*((CEU_Button*)_STK_ORG)->rect).y))))&&((((*(((CEU_Button*)_STK_ORG)->but_15)).x))<=((((*((CEU_Button*)_STK_ORG)->rect).x))+(((*((CEU_Button*)_STK_ORG)->rect).w)))))&&((((*(((CEU_Button*)_STK_ORG)->but_15)).y))<=((((*((CEU_Button*)_STK_ORG)->rect).y))+(((*((CEU_Button*)_STK_ORG)->rect).h)))))) {
/* NODE: Block 163 */

#line 47 "./my_types.ceu"
    {/* NODE: Stmts 162 */

#line 47 "./my_types.ceu"
    {/* NODE: Set 786 */

#line 47 "./my_types.ceu"
/* SET: on *//* NODE: Op1_not 157 */

#line 47 "./my_types.ceu"
    (((CEU_Button*)_STK_ORG)->on) = (!(((CEU_Button*)_STK_ORG)->on));/* NODE: EmitInt 161 */

#line 49 "./my_types.ceu"
    {

#line 49 "./my_types.ceu"
    tceu__bool __ceu_ps_161;
{
    tceu__bool __ceu_ps_161_ =
        { (((CEU_Button*)_STK_ORG)->on) };
    __ceu_ps_161 = __ceu_ps_161_;
}

#line 49 "./my_types.ceu"
    /* save the continuation to run after the emit */
_STK->trl->evt = CEU_IN__STK;
_STK->trl->lbl = Button_EmitInt_cont_6;
_STK->trl->stk = stack_curi(_ceu_go);
   /* awake in the same level as we are now (-1 vs the emit push below) */

/* trigger the event */
{
    tceu_stk stk;
             stk.evt  = 1;
#ifdef CEU_ORGS
#line 49 "./my_types.ceu"
             stk.evto = (tceu_org*) _STK_ORG;
#endif
#ifdef CEU_ORGS
             stk.org  = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
             stk.trl  = &_ceu_app->data->trls[0];
#ifdef CEU_CLEAR
             stk.stop = NULL;
#endif

#line 49 "./my_types.ceu"
                stk.evt_sz = sizeof(*(&__ceu_ps_161));
            ceu_sys_bcast(_ceu_app, _ceu_go, &stk, (&__ceu_ps_161));

#line 49 "./my_types.ceu"
    }
}

return RET_RESTART;

case Button_EmitInt_cont_6:;

#line 47 "./my_types.ceu"
    }
#line 47 "./my_types.ceu"
/* CLEAR: Block (47) */
#line 47 "./my_types.ceu"
    }} else {
/* NODE: Nothing 776 */
}

#line 44 "./my_types.ceu"
    }
#line 44 "./my_types.ceu"
/* CLEAR: Block (44) */
#line 44 "./my_types.ceu"
    }} else {
/* NODE: Nothing 772 */
}

#line 42 "./my_types.ceu"
    }
#line 42 "./my_types.ceu"
/* CLEAR: Block (42) */
#line 42 "./my_types.ceu"
    }
#line 41 "./my_types.ceu"
    }

#line 41 "./my_types.ceu"
    }
#line 41 "./my_types.ceu"
/* CLEAR: Block (41) */
#line 41 "./my_types.ceu"
    }
#line 41 "./my_types.ceu"
    }
#line 41 "./my_types.ceu"
/* CLEAR: Block (41) */
#line 41 "./my_types.ceu"
    }
#line 38 "./my_types.ceu"
case Button_ParOr_sub_3_2:;/* NODE: Block 212 */

#line 54 "./my_types.ceu"
    {/* NODE: Stmts 211 */

#line 54 "./my_types.ceu"
    {/* NODE: Block 794 */

#line 54 "./my_types.ceu"
    {/* NODE: Stmts 793 */

#line 54 "./my_types.ceu"
    {/* NODE: Stmts 792 */

#line 54 "./my_types.ceu"
    {
#line 54 "./my_types.ceu"
    }/* NODE: Loop 791 */

#line 54 "./my_types.ceu"
    for (;;) {
/* NODE: Block 209 */

#line 55 "./my_types.ceu"
    {/* NODE: Stmts 208 */

#line 55 "./my_types.ceu"
    {/* NODE: Stmts 821 */

#line 54 "./my_types.ceu"
    {/* NODE: Nothing 795 */
/* NODE: Await 788 */

#line 54 "./my_types.ceu"
    _CEU_NO_788_:
    if (0) { goto _CEU_NO_788_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_REDRAW;
    _STK->trl->lbl = Button_Awake_SDL_REDRAW_7;

#line 54 "./my_types.ceu"
    	return RET_HALT;
#line 54 "./my_types.ceu"
    case Button_Awake_SDL_REDRAW_7:;

#line 54 "./my_types.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1210 */
/* NODE: Nothing 1211 */

#line 54 "./my_types.ceu"
    }/* NODE: If 207 */

#line 55 "./my_types.ceu"
    if ((((CEU_Button*)_STK_ORG)->on)) {
/* NODE: Block 190 */

#line 56 "./my_types.ceu"
    {/* NODE: Stmts 189 */

#line 56 "./my_types.ceu"
    {/* NODE: CallStmt 188 */

#line 56 "./my_types.ceu"
    SDL_RenderCopy((((CEU_Button*)_STK_ORG)->ren),((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->tex_pressed),__FILE__,__LINE__)->SOME.v)),NULL,((SDL_Rect*)(((CEU_Button*)_STK_ORG)->rect)));
#line 56 "./my_types.ceu"
    }
#line 56 "./my_types.ceu"
/* CLEAR: Block (56) */
#line 56 "./my_types.ceu"
    }} else {
/* NODE: Block 206 */

#line 58 "./my_types.ceu"
    {/* NODE: Stmts 205 */

#line 58 "./my_types.ceu"
    {/* NODE: CallStmt 204 */

#line 58 "./my_types.ceu"
    SDL_RenderCopy((((CEU_Button*)_STK_ORG)->ren),((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->tex_normal),__FILE__,__LINE__)->SOME.v)),NULL,((SDL_Rect*)(((CEU_Button*)_STK_ORG)->rect)));
#line 58 "./my_types.ceu"
    }
#line 58 "./my_types.ceu"
/* CLEAR: Block (58) */
#line 58 "./my_types.ceu"
    }}

#line 55 "./my_types.ceu"
    }
#line 55 "./my_types.ceu"
/* CLEAR: Block (55) */
#line 55 "./my_types.ceu"
    }
#line 54 "./my_types.ceu"
    }

#line 54 "./my_types.ceu"
    }
#line 54 "./my_types.ceu"
/* CLEAR: Block (54) */
#line 54 "./my_types.ceu"
    }
#line 54 "./my_types.ceu"
    }
#line 54 "./my_types.ceu"
/* CLEAR: Block (54) */
#line 54 "./my_types.ceu"
    }
#line 38 "./my_types.ceu"
case Button_ParOr_out_3:;
#line 38 "./my_types.ceu"
/* CLEAR: ParOr (38) */
#line 38 "./my_types.ceu"
    return ceu_out_clear(_ceu_app, _ceu_go, Button_Clear_8, _STK_ORG,
                     &_STK_ORG->trls[ 0 ],
                     &_STK_ORG->trls[ 3 ]);

#line 38 "./my_types.ceu"
    case Button_Clear_8:;

#line 38 "./my_types.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ 0 ];

#line 10 "./my_types.ceu"
    }
#line 10 "./my_types.ceu"
/* CLEAR: Block (10) */
#line 10 "./my_types.ceu"
    return ceu_out_clear(_ceu_app, _ceu_go, Button_Clear_10, _STK_ORG,
                     &_STK_ORG->trls[ 0 ],
                     &_STK_ORG->trls[ 4 ]);

#line 10 "./my_types.ceu"
    {
    int __ceu_from_fin;         /* separate dcl/set because of C++ */
    __ceu_from_fin = 0;         /* skip HALT */
    if (0) {

#line 10 "./my_types.ceu"
case Button_Block__fin_9:;
#line 10 "./my_types.ceu"
            __ceu_from_fin = 1;         /* stop on HALT */
    }

#line 10 "./my_types.ceu"
        if (((CEU_Button*)_STK_ORG)->__fin_215_1) {
        /* NODE: Finally 112 */
/* NODE: Block 111 */

#line 35 "./my_types.ceu"
    {/* NODE: Stmts 110 */

#line 35 "./my_types.ceu"
    {/* NODE: CallStmt 109 */

#line 35 "./my_types.ceu"
    SDL_DestroyTexture(((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->tex_pressed),__FILE__,__LINE__)->SOME.v)));
#line 35 "./my_types.ceu"
    }
#line 35 "./my_types.ceu"
/* CLEAR: Block (35) */
#line 35 "./my_types.ceu"
    }    }

#line 10 "./my_types.ceu"
        if (((CEU_Button*)_STK_ORG)->__fin_215_2) {
        /* NODE: Finally 88 */
/* NODE: Block 87 */

#line 28 "./my_types.ceu"
    {/* NODE: Stmts 86 */

#line 28 "./my_types.ceu"
    {/* NODE: CallStmt 85 */

#line 28 "./my_types.ceu"
    SDL_FreeSurface(((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->sur_pressed),__FILE__,__LINE__)->SOME.v)));
#line 28 "./my_types.ceu"
    }
#line 28 "./my_types.ceu"
/* CLEAR: Block (28) */
#line 28 "./my_types.ceu"
    }    }

#line 10 "./my_types.ceu"
        if (((CEU_Button*)_STK_ORG)->__fin_215_3) {
        /* NODE: Finally 68 */
/* NODE: Block 67 */

#line 21 "./my_types.ceu"
    {/* NODE: Stmts 66 */

#line 21 "./my_types.ceu"
    {/* NODE: CallStmt 65 */

#line 21 "./my_types.ceu"
    SDL_DestroyTexture(((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->tex_normal),__FILE__,__LINE__)->SOME.v)));
#line 21 "./my_types.ceu"
    }
#line 21 "./my_types.ceu"
/* CLEAR: Block (21) */
#line 21 "./my_types.ceu"
    }    }

#line 10 "./my_types.ceu"
        if (((CEU_Button*)_STK_ORG)->__fin_215_4) {
        /* NODE: Finally 44 */
/* NODE: Block 43 */

#line 14 "./my_types.ceu"
    {/* NODE: Stmts 42 */

#line 14 "./my_types.ceu"
    {/* NODE: CallStmt 41 */

#line 14 "./my_types.ceu"
    SDL_FreeSurface(((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Button*)_STK_ORG)->sur_normal),__FILE__,__LINE__)->SOME.v)));
#line 14 "./my_types.ceu"
    }
#line 14 "./my_types.ceu"
/* CLEAR: Block (14) */
#line 14 "./my_types.ceu"
    }    }

#line 10 "./my_types.ceu"
        if (__ceu_from_fin) {
        return RET_HALT;
    }
}

#line 10 "./my_types.ceu"
    case Button_Clear_10:;

#line 10 "./my_types.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ 0 ];

#line 10 "./my_types.ceu"
    }
#line 3 "./my_types.ceu"
    }
#line 3 "./my_types.ceu"
/* CLEAR: Block (3) */
#line 3 "./my_types.ceu"
    }
#line 3 "./my_types.ceu"
    }
#line 3 "./my_types.ceu"
/* CLEAR: Block (3) */
#line 3 "./my_types.ceu"
    }
#line 3 "./my_types.ceu"
    #ifdef CEU_ORGS_NEWS
/* HACK_9:
 * If the stack top is the initial spawn state of the organism, it means that 
 * the organism terminated on start and the spawn must return NULL.
 * In this case, we mark it with "CEU_IN__NONE" to be recognized in the spawn 
 * continuation below.
 */
if (_STK->evt==CEU_IN__STK && _STK->org==_STK_ORG
    && _STK->trl==&_STK_ORG->trls[0]
    && _STK->stop==&_STK_ORG->trls[_STK_ORG->n]
    )
{
    _STK->evt = CEU_IN__NONE;
}
#endif

#line 3 "./my_types.ceu"
    #ifdef CEU_ORGS
{
    tceu_stk stk;
             stk.evt    = CEU_IN__CLEAR;
             stk.cnt    = NULL;
             stk.org    = _STK_ORG;
             stk.trl    = &_STK_ORG->trls[0];
             stk.stop   = _STK_ORG;
             stk.evt_sz = 0;
    stack_push(_ceu_app, _ceu_go, &stk, NULL);
}
#endif

#line 3 "./my_types.ceu"
    	return RET_RESTART;/* NODE: Dcl_cls 2 */

#line 65 "./my_types.ceu"
case Class_Bulb:;/* NODE: Block 922 */

#line 65 "./my_types.ceu"
    {/* NODE: Stmts 921 */

#line 65 "./my_types.ceu"
    {/* NODE: Block 831 */

#line 65 "./my_types.ceu"
    {/* NODE: Stmts 923 */

#line 65 "./my_types.ceu"
    {/* NODE: Block 358 */

#line 71 "./my_types.ceu"
    /*  FINALIZE */
_STK_ORG->trls[ 2 ].evt   = CEU_IN__CLEAR;
_STK_ORG->trls[ 2 ].lbl   = Bulb_Block__fin_18;

#line 71 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_1 = 0;
#line 71 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_2 = 0;
#line 71 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_3 = 0;
#line 71 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_4 = 0;
#line 71 "./my_types.ceu"
    {
#line 71 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->sur_off).tag = CEU__OPTION___SDL_SURFACE__REF_NIL;

#line 71 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->tex_off).tag = CEU__OPTION___SDL_TEXTURE__REF_NIL;

#line 71 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->sur_on).tag = CEU__OPTION___SDL_SURFACE__REF_NIL;

#line 71 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->tex_on).tag = CEU__OPTION___SDL_TEXTURE__REF_NIL;
/* NODE: Stmts 357 */

#line 71 "./my_types.ceu"
    {/* NODE: Stmts 846 */

#line 71 "./my_types.ceu"
    {/* NODE: Dcl_var 845 */

#line 71 "./my_types.ceu"
    }/* NODE: Finalize 243 */

#line 72 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_4 = 1;/* NODE: Set 847 */

#line 73 "./my_types.ceu"
/* SET: sur_off *//* NODE: Op1_& 231 */

#line 73 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->sur_off) = (CEU__OPTION___SDL_SURFACE__REF_pack(IMG_Load("samples/imgs/off.png")));/* NODE: Stmts 850 */

#line 78 "./my_types.ceu"
    {/* NODE: Dcl_var 849 */

#line 78 "./my_types.ceu"
    }/* NODE: Finalize 267 */

#line 79 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_3 = 1;/* NODE: Set 851 */

#line 80 "./my_types.ceu"
/* SET: tex_off *//* NODE: Op1_& 255 */

#line 80 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->tex_off) = (CEU__OPTION___SDL_TEXTURE__REF_pack(SDL_CreateTextureFromSurface((((CEU_Bulb*)_STK_ORG)->ren),((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->sur_off),__FILE__,__LINE__)->SOME.v)))));/* NODE: Stmts 854 */

#line 85 "./my_types.ceu"
    {/* NODE: Dcl_var 853 */

#line 85 "./my_types.ceu"
    }/* NODE: Finalize 287 */

#line 86 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_2 = 1;/* NODE: Set 855 */

#line 87 "./my_types.ceu"
/* SET: sur_on *//* NODE: Op1_& 275 */

#line 87 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->sur_on) = (CEU__OPTION___SDL_SURFACE__REF_pack(IMG_Load("samples/imgs/on.png")));/* NODE: Stmts 858 */

#line 92 "./my_types.ceu"
    {/* NODE: Dcl_var 857 */

#line 92 "./my_types.ceu"
    }/* NODE: Finalize 311 */

#line 93 "./my_types.ceu"
    ((CEU_Bulb*)_STK_ORG)->__fin_358_1 = 1;/* NODE: Set 859 */

#line 94 "./my_types.ceu"
/* SET: tex_on *//* NODE: Op1_& 299 */

#line 94 "./my_types.ceu"
    (((CEU_Bulb*)_STK_ORG)->tex_on) = (CEU__OPTION___SDL_TEXTURE__REF_pack(SDL_CreateTextureFromSurface((((CEU_Bulb*)_STK_ORG)->ren),((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->sur_on),__FILE__,__LINE__)->SOME.v)))));/* NODE: ParOr 356 */

#line 99 "./my_types.ceu"
/* ParOr: spawn subs */
#line 99 "./my_types.ceu"
    {
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ 1 ];
    trl->evt = CEU_IN__STK;
    trl->lbl = Bulb_ParOr_sub_2_13;
#ifdef CEU_STACK
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#endif
#ifdef CEU_DEBUG
    ceu_out_assert_msg(trl > _STK->trl, "bug found");
#endif
}
/* NODE: Block 315 */

#line 100 "./my_types.ceu"
    {/* NODE: Stmts 314 */

#line 100 "./my_types.ceu"
    {/* NODE: Stmts 886 */

#line 100 "./my_types.ceu"
    {/* NODE: Nothing 860 */
/* NODE: Await 313 */

#line 100 "./my_types.ceu"
    _CEU_NO_313_:
    if (0) { goto _CEU_NO_313_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_QUIT;
    _STK->trl->lbl = Bulb_Awake_SDL_QUIT_15;

#line 100 "./my_types.ceu"
    	return RET_HALT;
#line 100 "./my_types.ceu"
    case Bulb_Awake_SDL_QUIT_15:;

#line 100 "./my_types.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1212 */
/* NODE: Nothing 1213 */

#line 100 "./my_types.ceu"
    }
#line 100 "./my_types.ceu"
    }
#line 100 "./my_types.ceu"
/* CLEAR: Block (100) */
#line 100 "./my_types.ceu"
    }
#line 99 "./my_types.ceu"
/* PAROR JOIN */
#line 99 "./my_types.ceu"
    _CEU_LBL = Bulb_ParOr_out_14;
goto _CEU_GOTO_;

#line 99 "./my_types.ceu"
case Bulb_ParOr_sub_2_13:;/* NODE: Block 355 */

#line 102 "./my_types.ceu"
    {/* NODE: Stmts 354 */

#line 102 "./my_types.ceu"
    {/* NODE: Block 893 */

#line 102 "./my_types.ceu"
    {/* NODE: Stmts 892 */

#line 102 "./my_types.ceu"
    {/* NODE: Stmts 891 */

#line 102 "./my_types.ceu"
    {
#line 102 "./my_types.ceu"
    }/* NODE: Loop 890 */

#line 102 "./my_types.ceu"
    for (;;) {
/* NODE: Block 352 */

#line 103 "./my_types.ceu"
    {/* NODE: Stmts 351 */

#line 103 "./my_types.ceu"
    {/* NODE: Stmts 920 */

#line 102 "./my_types.ceu"
    {/* NODE: Nothing 894 */
/* NODE: Await 887 */

#line 102 "./my_types.ceu"
    _CEU_NO_887_:
    if (0) { goto _CEU_NO_887_; /* avoids "not used" warning */ }
    _STK->trl->evt = CEU_IN_SDL_REDRAW;
    _STK->trl->lbl = Bulb_Awake_SDL_REDRAW_16;

#line 102 "./my_types.ceu"
    	return RET_HALT;
#line 102 "./my_types.ceu"
    case Bulb_Awake_SDL_REDRAW_16:;

#line 102 "./my_types.ceu"
    #ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
/* NODE: Nothing 1214 */
/* NODE: Nothing 1215 */

#line 102 "./my_types.ceu"
    }/* NODE: If 350 */

#line 103 "./my_types.ceu"
    if ((((CEU_Bulb*)_STK_ORG)->on)) {
/* NODE: Block 333 */

#line 104 "./my_types.ceu"
    {/* NODE: Stmts 332 */

#line 104 "./my_types.ceu"
    {/* NODE: CallStmt 331 */

#line 104 "./my_types.ceu"
    SDL_RenderCopy((((CEU_Bulb*)_STK_ORG)->ren),((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->tex_on),__FILE__,__LINE__)->SOME.v)),NULL,((SDL_Rect*)(((CEU_Bulb*)_STK_ORG)->rect)));
#line 104 "./my_types.ceu"
    }
#line 104 "./my_types.ceu"
/* CLEAR: Block (104) */
#line 104 "./my_types.ceu"
    }} else {
/* NODE: Block 349 */

#line 106 "./my_types.ceu"
    {/* NODE: Stmts 348 */

#line 106 "./my_types.ceu"
    {/* NODE: CallStmt 347 */

#line 106 "./my_types.ceu"
    SDL_RenderCopy((((CEU_Bulb*)_STK_ORG)->ren),((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->tex_off),__FILE__,__LINE__)->SOME.v)),NULL,((SDL_Rect*)(((CEU_Bulb*)_STK_ORG)->rect)));
#line 106 "./my_types.ceu"
    }
#line 106 "./my_types.ceu"
/* CLEAR: Block (106) */
#line 106 "./my_types.ceu"
    }}

#line 103 "./my_types.ceu"
    }
#line 103 "./my_types.ceu"
/* CLEAR: Block (103) */
#line 103 "./my_types.ceu"
    }
#line 102 "./my_types.ceu"
    }

#line 102 "./my_types.ceu"
    }
#line 102 "./my_types.ceu"
/* CLEAR: Block (102) */
#line 102 "./my_types.ceu"
    }
#line 102 "./my_types.ceu"
    }
#line 102 "./my_types.ceu"
/* CLEAR: Block (102) */
#line 102 "./my_types.ceu"
    }
#line 99 "./my_types.ceu"
case Bulb_ParOr_out_14:;
#line 99 "./my_types.ceu"
/* CLEAR: ParOr (99) */
#line 99 "./my_types.ceu"
    return ceu_out_clear(_ceu_app, _ceu_go, Bulb_Clear_17, _STK_ORG,
                     &_STK_ORG->trls[ 0 ],
                     &_STK_ORG->trls[ 2 ]);

#line 99 "./my_types.ceu"
    case Bulb_Clear_17:;

#line 99 "./my_types.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ 0 ];

#line 71 "./my_types.ceu"
    }
#line 71 "./my_types.ceu"
/* CLEAR: Block (71) */
#line 71 "./my_types.ceu"
    return ceu_out_clear(_ceu_app, _ceu_go, Bulb_Clear_19, _STK_ORG,
                     &_STK_ORG->trls[ 0 ],
                     &_STK_ORG->trls[ 3 ]);

#line 71 "./my_types.ceu"
    {
    int __ceu_from_fin;         /* separate dcl/set because of C++ */
    __ceu_from_fin = 0;         /* skip HALT */
    if (0) {

#line 71 "./my_types.ceu"
case Bulb_Block__fin_18:;
#line 71 "./my_types.ceu"
            __ceu_from_fin = 1;         /* stop on HALT */
    }

#line 71 "./my_types.ceu"
        if (((CEU_Bulb*)_STK_ORG)->__fin_358_1) {
        /* NODE: Finally 310 */
/* NODE: Block 309 */

#line 96 "./my_types.ceu"
    {/* NODE: Stmts 308 */

#line 96 "./my_types.ceu"
    {/* NODE: CallStmt 307 */

#line 96 "./my_types.ceu"
    SDL_DestroyTexture(((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->tex_on),__FILE__,__LINE__)->SOME.v)));
#line 96 "./my_types.ceu"
    }
#line 96 "./my_types.ceu"
/* CLEAR: Block (96) */
#line 96 "./my_types.ceu"
    }    }

#line 71 "./my_types.ceu"
        if (((CEU_Bulb*)_STK_ORG)->__fin_358_2) {
        /* NODE: Finally 286 */
/* NODE: Block 285 */

#line 89 "./my_types.ceu"
    {/* NODE: Stmts 284 */

#line 89 "./my_types.ceu"
    {/* NODE: CallStmt 283 */

#line 89 "./my_types.ceu"
    SDL_FreeSurface(((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->sur_on),__FILE__,__LINE__)->SOME.v)));
#line 89 "./my_types.ceu"
    }
#line 89 "./my_types.ceu"
/* CLEAR: Block (89) */
#line 89 "./my_types.ceu"
    }    }

#line 71 "./my_types.ceu"
        if (((CEU_Bulb*)_STK_ORG)->__fin_358_3) {
        /* NODE: Finally 266 */
/* NODE: Block 265 */

#line 82 "./my_types.ceu"
    {/* NODE: Stmts 264 */

#line 82 "./my_types.ceu"
    {/* NODE: CallStmt 263 */

#line 82 "./my_types.ceu"
    SDL_DestroyTexture(((CEU__OPTION___SDL_TEXTURE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->tex_off),__FILE__,__LINE__)->SOME.v)));
#line 82 "./my_types.ceu"
    }
#line 82 "./my_types.ceu"
/* CLEAR: Block (82) */
#line 82 "./my_types.ceu"
    }    }

#line 71 "./my_types.ceu"
        if (((CEU_Bulb*)_STK_ORG)->__fin_358_4) {
        /* NODE: Finally 242 */
/* NODE: Block 241 */

#line 75 "./my_types.ceu"
    {/* NODE: Stmts 240 */

#line 75 "./my_types.ceu"
    {/* NODE: CallStmt 239 */

#line 75 "./my_types.ceu"
    SDL_FreeSurface(((CEU__OPTION___SDL_SURFACE__REF_SOME_assert(_ceu_app, (&((CEU_Bulb*)_STK_ORG)->sur_off),__FILE__,__LINE__)->SOME.v)));
#line 75 "./my_types.ceu"
    }
#line 75 "./my_types.ceu"
/* CLEAR: Block (75) */
#line 75 "./my_types.ceu"
    }    }

#line 71 "./my_types.ceu"
        if (__ceu_from_fin) {
        return RET_HALT;
    }
}

#line 71 "./my_types.ceu"
    case Bulb_Clear_19:;

#line 71 "./my_types.ceu"
    /* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ 0 ];

#line 71 "./my_types.ceu"
    }
#line 65 "./my_types.ceu"
    }
#line 65 "./my_types.ceu"
/* CLEAR: Block (65) */
#line 65 "./my_types.ceu"
    }
#line 65 "./my_types.ceu"
    }
#line 65 "./my_types.ceu"
/* CLEAR: Block (65) */
#line 65 "./my_types.ceu"
    }
#line 65 "./my_types.ceu"
    #ifdef CEU_ORGS_NEWS
/* HACK_9:
 * If the stack top is the initial spawn state of the organism, it means that 
 * the organism terminated on start and the spawn must return NULL.
 * In this case, we mark it with "CEU_IN__NONE" to be recognized in the spawn 
 * continuation below.
 */
if (_STK->evt==CEU_IN__STK && _STK->org==_STK_ORG
    && _STK->trl==&_STK_ORG->trls[0]
    && _STK->stop==&_STK_ORG->trls[_STK_ORG->n]
    )
{
    _STK->evt = CEU_IN__NONE;
}
#endif

#line 65 "./my_types.ceu"
    #ifdef CEU_ORGS
{
    tceu_stk stk;
             stk.evt    = CEU_IN__CLEAR;
             stk.cnt    = NULL;
             stk.org    = _STK_ORG;
             stk.trl    = &_STK_ORG->trls[0];
             stk.stop   = _STK_ORG;
             stk.evt_sz = 0;
    stack_push(_ceu_app, _ceu_go, &stk, NULL);
}
#endif

#line 65 "./my_types.ceu"
    	return RET_RESTART;
    }
#ifdef CEU_DEBUG
    ceu_out_assert_msg(0, "no return");
#endif
    return RET_HALT;    /* TODO: should never be reached anyways */
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* _ceu_app)
{
#ifdef CEU_INTS
    _ceu_app->seqno = 0;
#endif
#if defined(CEU_RET) || defined(CEU_OS_APP)
    _ceu_app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    _ceu_app->pendingAsyncs = 1;
#endif
#ifdef CEU_REENTRANT
    _ceu_app->stki = 0;
#endif
#ifdef CEU_RET
    _ceu_app->ret = 0;
#endif
#ifdef CEU_WCLOCKS
    _ceu_app->wclk_late = 0;
    _ceu_app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    _ceu_app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    _ceu_app->wclk_late_ = 0;
    _ceu_app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    _ceu_app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&_ceu_app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    _ceu_app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
#endif

    

#ifdef CEU_OS_APP

#ifdef __AVR
    _ceu_app->code  = (__typeof__(ceu_app_go)*)    (((word)_ceu_app->addr>>1) + &ceu_app_go);
    _ceu_app->calls = (__typeof__(ceu_app_calls)*) (((word)_ceu_app->addr>>1) + &ceu_app_calls);
#else
    _ceu_app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    _ceu_app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS_APP */

    _ceu_app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS_APP */

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = _ceu_app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org(_ceu_app, _ceu_app->data, CEU_NTRAILS, Class_Main,
                0, 0,
                NULL, NULL);

#ifdef CEU_LUA
    ceu_luaL_newstate(_ceu_app->lua);
    ceu_out_assert(_ceu_app->lua != NULL);
    ceu_luaL_openlibs(_ceu_app->lua);
    ceu_lua_atpanic(_ceu_app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    ceu_out_go(_ceu_app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
